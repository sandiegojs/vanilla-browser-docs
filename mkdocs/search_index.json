{
    "docs": [
        {
            "location": "/", 
            "text": "Vanilla JavaScript in the Browser Workshop\n\n\nOverview\n\n\nWelcome to Vanilla JavaScript in the Browser workshop hosted by \nSan Diego JS\n.\n\n\nThe goal of this workshop is to learn how to effectively use vanilla JavaScript in the browser.\n\n\nModern web development workflows often rely on libraries like jQuery. But using libraries can add a lot of unneeded bloat to your project. This workshop will help you dig a little deeper into JavaScript and how to use the available browser APIs without using the $.\n\n\nThis workshop will feature:\n\n\n\n\nDOM API\n\n\nBrowser Event API\n\n\nUsing Cookies\n\n\nXHR Requests\n\n\nDynamic HTML\n\n\nTesting with Mocha\n\n\n\n\nThe example\n\n\nFor this workshop, we are going to build out a business card creator. There is a simple html form inside of \napp/index.html\n that we will build upon and add life to. We'll collect common profile information that one would normally share professionally, like contact info and skills, and then display it.\n\n\nKeep your resources handy\n\n\nWorkshops are fun and can be a fast way to learn while building something potentially reusable. There will come a time, however, when you'll want to reference the API and see if there are other methods or functionality that you didn't know existed.\n\n\nA really good open-source resource that also provides great offline functionality for you future digital nomads is \nDevDocs.io\n. You can select the different APIs you want to be immediately searchable and they cover everything from the browser, to Node, to Rails, to Elixir, and even more you never even knew about!\n\n\nFor this workshop, it may be useful to reference the sections that will align with this workshop:\n\n\n\n\nDOM API\n\n\nBrowser Event API\n\n\nUsing Cookies\n\n\nXHR Requests\n\n\nTesting with Mocha\n\n\n\n\nAnother good resource for learning about the available APIs and even the internals of how a browser parses, executes, and draws a page, is \nMozilla Developer Network\n.\n\n\nHave any other great resources you've used? We would love to hear about them and share them with the other attendees!\n\n\nPre-event Setup Instructions\n\n\nPrior to your arrival the following should be installed on your system:\n\n\n\n\nInstall Git\n\n\nInstall Node.js 4.2 LTS\n\n\nSetup NPM for non-sudo installation\n\n\nNPM is the node package manager.  It will automatically be installed when you install node.\n\n\nNPM installs packages \nlocally\n (within the directory it is invoked in) for per-project modules, or \nglobally\n for packages you want accessible everywhere.\n\n\nHowever, by default NPM installs global packages in a root-restricted location, requiring SUDO to install.  This creates a \nhuge\n headache.  As an alternative, \nbefore\n you install any packages, follow \nthis guide\n to configure your NPM to install in your home directory without requiring sudo.\n\n\n\n\n\n\n\n\nClone the workshop repository:\n\n\ngit clone git@github.com:sandiegojs/vanilla-browser-workshop.git\n\n\n\n\n\n\n\nChange directories into the workshop folder and install your local dependencies with:\n\n\ncd vanilla-browser-workshop\nnpm install\n\n\n\n\n\n\n\nInstall these global dependencies using the \n-g\n flag (ex \nnpm install \npackage\n -g\n)\n\n\n\n\ngulp\n\n\nmocha\n\n\n\n\n\n\nIf you plan to deploy your app onto Heroku, setup \nHeroku Toolbelt\n\n\n\n\nAPI service\n\n\nThe app we will be building is a client-side application, meaning it will be running in a user's browser. We will need to persist the data that we are\ncreating to a backend service and database so that we can recall it later.\n\n\nWe could use fixture data or a mock service for this, but some friendly backend\ndevelopers have already made a working API for us, so let's use that.\n\n\nOur API is setup at \n//sandiegojs-vanilla-workshop.herokuapp.com\n and supports the following endpoints\n\n\n\n  \n\n    \n\n    \n\n    \n\n  \n\n  \n\n    \n\n      \nVerb\npath\nDescription\n\n    \n\n  \n\n  \n\n    \n\n      \nGET\n/forms\nList of forms\n\n    \n\n    \n\n      \nPOST\n/forms\nCreate a new form\n\n    \n\n    \n\n      \nGET\n/forms/:id\nRetrieve a form\n\n    \n\n    \n\n      \nPUT\n/forms/:id\nUpdate a form\n\n    \n\n    \n\n      \nDELETE\n/forms/:id\nDelete a form\n\n    \n\n  \n\n\n\n\n\nGetting started\n\n\nThis project uses the build tool \nGulp\n to automate a bunch of stuff for you. The gulp tasks are all defined in the \ntasks\n directory if you're the curious type. They are used to compile the sources and styles found within the \napp\n directory and put the final compiled source and styles into the \npublic\n directory. The \npublic/index.html\n file will include the final styles and scripts inside of it.\n\n\nEverything in the \npublic/\n directory of this application is created by Gulp. Think of this as our staging area. We should never be messing with the files in this directory directly. Instead, we should be editing and changing the origin files found in the \napp/\n directory and running Gulp in the terminal to bundle our project.\n\n\nIn order to get started, this boilerplate has been setup to show us a simple form right from the start. So let's dive in and give the gulp step a try!\n\n\nType the following from the root of the project:\n\n\n$ gulp\n\n\n\n\nYou should see some output similar to the following:\n\n\n$ gulp\n[16:02:13] Requiring external module babel-core/register\n[16:02:14] Using gulpfile ~/Code/vanilla-browser-workshop/gulpfile.babel.js\n[16:02:14] Starting 'scripts'...\n[16:02:14] Starting 'styles'...\n[16:02:14] Starting 'serve'...\n[16:02:14] Finished 'serve' after 46 ms\nlivereload[tiny-lr] listening on 35729 ...\n[16:02:15] Finished 'styles' after 175 ms\n[16:02:15] Finished 'scripts' after 355 ms\n[16:02:15] Starting 'default'...\n[16:02:15] Finished 'default' after 114 \u03bcs\nfolder \npublic\n serving at http://localhost:3000\n\n\n\n\nAs you can see, the scripts and styles are compiled, and then the server gets started. Now that we have that running, let's jump over to the browser and visit \nlocalhost:3000\n.\n\n\n\n\nCool! We have a very simple form with some basic styling already good to go for us.\n\n\nIf you're having issues bug one of the instructors! We're here to help you out.", 
            "title": "Home"
        }, 
        {
            "location": "/#vanilla-javascript-in-the-browser-workshop", 
            "text": "", 
            "title": "Vanilla JavaScript in the Browser Workshop"
        }, 
        {
            "location": "/#overview", 
            "text": "Welcome to Vanilla JavaScript in the Browser workshop hosted by  San Diego JS .  The goal of this workshop is to learn how to effectively use vanilla JavaScript in the browser.  Modern web development workflows often rely on libraries like jQuery. But using libraries can add a lot of unneeded bloat to your project. This workshop will help you dig a little deeper into JavaScript and how to use the available browser APIs without using the $.  This workshop will feature:   DOM API  Browser Event API  Using Cookies  XHR Requests  Dynamic HTML  Testing with Mocha", 
            "title": "Overview"
        }, 
        {
            "location": "/#the-example", 
            "text": "For this workshop, we are going to build out a business card creator. There is a simple html form inside of  app/index.html  that we will build upon and add life to. We'll collect common profile information that one would normally share professionally, like contact info and skills, and then display it.", 
            "title": "The example"
        }, 
        {
            "location": "/#keep-your-resources-handy", 
            "text": "Workshops are fun and can be a fast way to learn while building something potentially reusable. There will come a time, however, when you'll want to reference the API and see if there are other methods or functionality that you didn't know existed.  A really good open-source resource that also provides great offline functionality for you future digital nomads is  DevDocs.io . You can select the different APIs you want to be immediately searchable and they cover everything from the browser, to Node, to Rails, to Elixir, and even more you never even knew about!  For this workshop, it may be useful to reference the sections that will align with this workshop:   DOM API  Browser Event API  Using Cookies  XHR Requests  Testing with Mocha   Another good resource for learning about the available APIs and even the internals of how a browser parses, executes, and draws a page, is  Mozilla Developer Network .  Have any other great resources you've used? We would love to hear about them and share them with the other attendees!", 
            "title": "Keep your resources handy"
        }, 
        {
            "location": "/#pre-event-setup-instructions", 
            "text": "Prior to your arrival the following should be installed on your system:   Install Git  Install Node.js 4.2 LTS  Setup NPM for non-sudo installation  NPM is the node package manager.  It will automatically be installed when you install node.  NPM installs packages  locally  (within the directory it is invoked in) for per-project modules, or  globally  for packages you want accessible everywhere.  However, by default NPM installs global packages in a root-restricted location, requiring SUDO to install.  This creates a  huge  headache.  As an alternative,  before  you install any packages, follow  this guide  to configure your NPM to install in your home directory without requiring sudo.     Clone the workshop repository:  git clone git@github.com:sandiegojs/vanilla-browser-workshop.git    Change directories into the workshop folder and install your local dependencies with:  cd vanilla-browser-workshop\nnpm install    Install these global dependencies using the  -g  flag (ex  npm install  package  -g )   gulp  mocha    If you plan to deploy your app onto Heroku, setup  Heroku Toolbelt", 
            "title": "Pre-event Setup Instructions"
        }, 
        {
            "location": "/#api-service", 
            "text": "The app we will be building is a client-side application, meaning it will be running in a user's browser. We will need to persist the data that we are\ncreating to a backend service and database so that we can recall it later.  We could use fixture data or a mock service for this, but some friendly backend\ndevelopers have already made a working API for us, so let's use that.  Our API is setup at  //sandiegojs-vanilla-workshop.herokuapp.com  and supports the following endpoints  \n   \n     \n     \n     \n   \n   \n     \n       Verb path Description \n     \n   \n   \n     \n       GET /forms List of forms \n     \n     \n       POST /forms Create a new form \n     \n     \n       GET /forms/:id Retrieve a form \n     \n     \n       PUT /forms/:id Update a form \n     \n     \n       DELETE /forms/:id Delete a form", 
            "title": "API service"
        }, 
        {
            "location": "/#getting-started", 
            "text": "This project uses the build tool  Gulp  to automate a bunch of stuff for you. The gulp tasks are all defined in the  tasks  directory if you're the curious type. They are used to compile the sources and styles found within the  app  directory and put the final compiled source and styles into the  public  directory. The  public/index.html  file will include the final styles and scripts inside of it.  Everything in the  public/  directory of this application is created by Gulp. Think of this as our staging area. We should never be messing with the files in this directory directly. Instead, we should be editing and changing the origin files found in the  app/  directory and running Gulp in the terminal to bundle our project.  In order to get started, this boilerplate has been setup to show us a simple form right from the start. So let's dive in and give the gulp step a try!  Type the following from the root of the project:  $ gulp  You should see some output similar to the following:  $ gulp\n[16:02:13] Requiring external module babel-core/register\n[16:02:14] Using gulpfile ~/Code/vanilla-browser-workshop/gulpfile.babel.js\n[16:02:14] Starting 'scripts'...\n[16:02:14] Starting 'styles'...\n[16:02:14] Starting 'serve'...\n[16:02:14] Finished 'serve' after 46 ms\nlivereload[tiny-lr] listening on 35729 ...\n[16:02:15] Finished 'styles' after 175 ms\n[16:02:15] Finished 'scripts' after 355 ms\n[16:02:15] Starting 'default'...\n[16:02:15] Finished 'default' after 114 \u03bcs\nfolder  public  serving at http://localhost:3000  As you can see, the scripts and styles are compiled, and then the server gets started. Now that we have that running, let's jump over to the browser and visit  localhost:3000 .   Cool! We have a very simple form with some basic styling already good to go for us.  If you're having issues bug one of the instructors! We're here to help you out.", 
            "title": "Getting started"
        }, 
        {
            "location": "/dom/", 
            "text": "The HTML\n\n\nWe should know what kind of document we are working with before we move forward. Since the boilerplate was setup for us, we'll need to open up the \napp/index.html\n file and take a look.\n\n\nYou should see that the styles are included in the header from \napp/index.css\n and the script for our JavaScript is included at the top of the body from \npublic/index.js\n. All of our JavaScript files in \napp/\n are compiled by Gulp into a single file, \npublic/index.js\n\n\nProTip\u2122:\n When the browser encounters a \nscript\n tag, it is blocking - meaning the browser will immediately download and execute it. To load the \nscript\n asynchronously and not block the browser's parsing of the document, set the attribute \nasync='true'\n on the tag.\n\n\nWithin the \napp/index.html\n you should see a form with labels and inputs. Familiarize yourself with the different fields.\n\n\nAre you ready to get coding?\n\n\nHTML field validation\n\n\nHave you ever used a form where you didn't realize you missed a required field until after clicking the submit button? Waiting for the page to send data off to the server, waiting for the page to reload, and then finally to get the perplexing red error message at the top. What a pain!\n\n\nLet's save our users the hassle and let them know right away that they are required to fill in certain fields \nbefore\n sending anything off to the server.\n\n\nThere are a few different ways to do this, and we will elaborate on this later, but the most basic way to get going with form validation is using the built-in HTML field validations.\n\n\nRequired fields\n\n\nWe really only need the \"name\" and \"email\" field to be required. In order to make these inputs required, all we have to do is add the word \nrequired\n as an attribute on the \ninput\n tag.\n\n\nFor example:\n\n\ninput type='text' placeholder='Name' required\n\n\n\n\nGo ahead and update the \"name\" and \"email\" inputs to include this special attribute.\n\n\nAfter making any changes to this project, be sure to save the file and reload your browser!\n\n\nLet's head over to \nlocalhost:3000\n again and try it out.\n\n\nIf you hit the submit button now, you should immediately see a pop-up message near the first missing input telling you the field is required like below.\n\n\n\n\nNeato! This is all taken care of for you by the browser out-of-the-box!\n\n\nNative validations\n\n\nSome \ninput\n types have intrinsic constraints, such as \ntype='email'\n. If you look at the \napp/index.html\n you will see that our email field is currently setup as a \ntype='text'\n. Go ahead and change this to an \nemail\n field.\n\n\nOnce you have changed our \"email\" field to type \nemail\n, you can test it out. Head over to the browser, type in a \"Name\" value (so that we don't get the required error) and type in a phoney string that doesn't look like an email address. Once you hit submit, you should see a message telling you that your input doesn't look like an email.\n\n\n\n\nIf you want to learn more about validations that are available for inputs, \nMDN has a great article covering the details\n.\n\n\nThe DOM\n\n\nThe Document Object Model (DOM) is how we are able to interact with our page via JavaScript. The DOM is a representation of what is on the page, including the elements and styles.\n\n\n\n\nThe Document Object Model (DOM) is a programming interface for HTML, XML and SVG documents. It provides a structured representation of the document (a tree) and it defines a way that the structure can be accessed from programs so that they can change the document structure, style and content. The DOM provides a representation of the document as a structured group of nodes and objects that have properties and methods. Nodes can also have event handlers attached to them, and once that event is triggered the event handlers get executed. Essentially, it connects web pages to scripts or programming languages. -\nMDN\n\n\n\n\nOne of the trickiest things about the DOM is that it's up to the browser vendor to implement it and therefore every implementation is a little different. This is why we get browser compatibility issues.\n\n\nBut as you will see there is a large API exposed by the DOM which allows us to craft powerful user experiences. An easy way to think of the DOM is a tree of nested nodes and each node is an element from our HTML document, e.g. a \ndiv\n, \np\n, \nbutton\n, etc...\n\n\nTo visualize this all you need to do is open your web inspector and look at the \nElements\n tab to see this structure realized. Each one of those nodes (elements) has many properties and functions you can take advantage of.\n\n\nIn Chrome on OSX you can open the web inspector with the keyboard shortcut \nCommand + Option + j\n or \nCommand + Option + i\n and \nControl + Shift + j\n on Windows.\n\n\n\n\nDOM selection\n\n\nIn order to interact with the DOM within JavaScript, the first thing you will need to understand is element selection. By selecting an element (DOM node) we get a reference to that element which allows us to take actions on it.\n\n\nThere are several functions we can use to get a reference to a DOM node. Overtime these functions have been introduced to solve different needs. As such, the browser support for them can vary. You should always research browser compatibility to ensure they will work for your user base.\n\n\n\n\nquerySelector\n\n\nquerySelectorAll\n\n\ngetElementById\n\n\ngetElementsByClassName\n\n\ngetElementsByName\n\n\ngetElementsByTagName\n\n\n\n\nFor now, we are going to focus on \nquerySelector\n. This function allows you to specify a \ncss selector\n that will be used to find the first matching node. One of the nice feature of this function is that it is available both on the \ndocument\n as well as \nelement\n. This means you can search for an element in the entire document or narrow your search to the child elements of an existing element.\n\n\nFor now, let's just open up the dev console and mess around. In Chrome OSX this can be accomplished with the keyboard shortcut \nCommand + Option + j\n or \nCommand + Option + i\n and \nControl + Shift + j\n on Windows. We can begin by selecting the input with a name attribute of \nname\n.\n\n\nvar inputName = document.querySelector('input[name=\nname\n]')\n\n\n\n\nThis sets the variable inputName to an \nHTMLInputElement\n which has a \nvalue\n property available. Go ahead and set the value property to see an example of how you can change the DOM.\n\n\ninputName.value = 'My new value!'\n\n\n\n\nYou should see the value you set reflected in the form's input.\n\n\nWhenever dealing with a DOM node it's important to understand what type of element you have and what are its parents. That will determine the properties and functions available to you.\n\n\nEvent handling\n\n\nWhen users interact with the web page the DOM publishes these interactions as events, for example \nclick\n, \nscroll\n, \nkeypress\n, and \nmore\n.\n\n\nAfter selecting an element from the DOM, we can call its \naddEventListener\n method which will execute a callback function we provide any time that event occurs. Lets start by listening for a \nclick\n on the \ndocument\n and trigger an \nalert\n whenever the user clicks anywhere on the page.\n\n\nWe are going to keep working in the dev console for now, and continue to mess around. Once we get the hang of event handlers, we can start building our app. But for now, let's just keep using the dev console.\n\n\nvar handler = function() {\n  alert('user clicked on the page')\n}\n\ndocument.addEventListener('click', handler)\n\n\n\n\nNow if you click on the page you should receive an alert with your message. Alerting users every time they click the page can get annoying so lets remove that event listener.\n\n\ndocument.removeEventListener('click', handler)\n\n\n\n\nIt's important to note that in order for us to be able to remove an event listener we need to keep a reference to our functions so we can specify which listener function to remove.\n\n\nUsing this simple API we can trigger the complex logic we will be writing shortly.\n\n\nMultiple event listeners\n\n\nOne of the great things about event listeners is that we can attach multiple listeners per event. For example:\n\n\nvar handlerOne = function() {\n  // Do some logic\n}\n\nvar handlerTwo = function() {\n  // Do some logic\n}\n\ndocument.addEventListener('click', handlerOne)\ndocument.addEventListener('click', handlerTwo)\n\n\n\n\nNow both of these functions will be executed whenever someone clicks the page.\n\n\nEvent listener argument\n\n\nWhen we attach callback functions to events these functions are passed as an event argument. The type of event given will change depending on the type of input device which triggered it. Since we are listening for a \nclick\n event we will receive a \nMouseEvent\n.\n\n\nvar logEvent = function(evt) {\n  console.log(evt)\n}\n\ndocument.addEventListener('click', logEvent)\n\n\n\n\nIf you inspect this event in the console you will see there are quite a few properties available to us. The ones most commonly used are \ntarget\n and \ncurrentTarget\n.\n\n\ntarget\n is the element that dispatched the event.\n\n\ncurrentTarget\n is the element that handled the event during the event capture (a.k.a bubbling) phase.\n\n\nAlthough important, we won't dive into the distinction between these two just yet. We will be using the \ncurrentTarget\n property to get a reference to the element that is listened to this event.", 
            "title": "The DOM"
        }, 
        {
            "location": "/dom/#the-html", 
            "text": "We should know what kind of document we are working with before we move forward. Since the boilerplate was setup for us, we'll need to open up the  app/index.html  file and take a look.  You should see that the styles are included in the header from  app/index.css  and the script for our JavaScript is included at the top of the body from  public/index.js . All of our JavaScript files in  app/  are compiled by Gulp into a single file,  public/index.js  ProTip\u2122:  When the browser encounters a  script  tag, it is blocking - meaning the browser will immediately download and execute it. To load the  script  asynchronously and not block the browser's parsing of the document, set the attribute  async='true'  on the tag.  Within the  app/index.html  you should see a form with labels and inputs. Familiarize yourself with the different fields.  Are you ready to get coding?", 
            "title": "The HTML"
        }, 
        {
            "location": "/dom/#html-field-validation", 
            "text": "Have you ever used a form where you didn't realize you missed a required field until after clicking the submit button? Waiting for the page to send data off to the server, waiting for the page to reload, and then finally to get the perplexing red error message at the top. What a pain!  Let's save our users the hassle and let them know right away that they are required to fill in certain fields  before  sending anything off to the server.  There are a few different ways to do this, and we will elaborate on this later, but the most basic way to get going with form validation is using the built-in HTML field validations.", 
            "title": "HTML field validation"
        }, 
        {
            "location": "/dom/#required-fields", 
            "text": "We really only need the \"name\" and \"email\" field to be required. In order to make these inputs required, all we have to do is add the word  required  as an attribute on the  input  tag.  For example:  input type='text' placeholder='Name' required   Go ahead and update the \"name\" and \"email\" inputs to include this special attribute.  After making any changes to this project, be sure to save the file and reload your browser!  Let's head over to  localhost:3000  again and try it out.  If you hit the submit button now, you should immediately see a pop-up message near the first missing input telling you the field is required like below.   Neato! This is all taken care of for you by the browser out-of-the-box!", 
            "title": "Required fields"
        }, 
        {
            "location": "/dom/#native-validations", 
            "text": "Some  input  types have intrinsic constraints, such as  type='email' . If you look at the  app/index.html  you will see that our email field is currently setup as a  type='text' . Go ahead and change this to an  email  field.  Once you have changed our \"email\" field to type  email , you can test it out. Head over to the browser, type in a \"Name\" value (so that we don't get the required error) and type in a phoney string that doesn't look like an email address. Once you hit submit, you should see a message telling you that your input doesn't look like an email.   If you want to learn more about validations that are available for inputs,  MDN has a great article covering the details .", 
            "title": "Native validations"
        }, 
        {
            "location": "/dom/#the-dom", 
            "text": "The Document Object Model (DOM) is how we are able to interact with our page via JavaScript. The DOM is a representation of what is on the page, including the elements and styles.   The Document Object Model (DOM) is a programming interface for HTML, XML and SVG documents. It provides a structured representation of the document (a tree) and it defines a way that the structure can be accessed from programs so that they can change the document structure, style and content. The DOM provides a representation of the document as a structured group of nodes and objects that have properties and methods. Nodes can also have event handlers attached to them, and once that event is triggered the event handlers get executed. Essentially, it connects web pages to scripts or programming languages. - MDN   One of the trickiest things about the DOM is that it's up to the browser vendor to implement it and therefore every implementation is a little different. This is why we get browser compatibility issues.  But as you will see there is a large API exposed by the DOM which allows us to craft powerful user experiences. An easy way to think of the DOM is a tree of nested nodes and each node is an element from our HTML document, e.g. a  div ,  p ,  button , etc...  To visualize this all you need to do is open your web inspector and look at the  Elements  tab to see this structure realized. Each one of those nodes (elements) has many properties and functions you can take advantage of.  In Chrome on OSX you can open the web inspector with the keyboard shortcut  Command + Option + j  or  Command + Option + i  and  Control + Shift + j  on Windows.", 
            "title": "The DOM"
        }, 
        {
            "location": "/dom/#dom-selection", 
            "text": "In order to interact with the DOM within JavaScript, the first thing you will need to understand is element selection. By selecting an element (DOM node) we get a reference to that element which allows us to take actions on it.  There are several functions we can use to get a reference to a DOM node. Overtime these functions have been introduced to solve different needs. As such, the browser support for them can vary. You should always research browser compatibility to ensure they will work for your user base.   querySelector  querySelectorAll  getElementById  getElementsByClassName  getElementsByName  getElementsByTagName   For now, we are going to focus on  querySelector . This function allows you to specify a  css selector  that will be used to find the first matching node. One of the nice feature of this function is that it is available both on the  document  as well as  element . This means you can search for an element in the entire document or narrow your search to the child elements of an existing element.  For now, let's just open up the dev console and mess around. In Chrome OSX this can be accomplished with the keyboard shortcut  Command + Option + j  or  Command + Option + i  and  Control + Shift + j  on Windows. We can begin by selecting the input with a name attribute of  name .  var inputName = document.querySelector('input[name= name ]')  This sets the variable inputName to an  HTMLInputElement  which has a  value  property available. Go ahead and set the value property to see an example of how you can change the DOM.  inputName.value = 'My new value!'  You should see the value you set reflected in the form's input.  Whenever dealing with a DOM node it's important to understand what type of element you have and what are its parents. That will determine the properties and functions available to you.", 
            "title": "DOM selection"
        }, 
        {
            "location": "/dom/#event-handling", 
            "text": "When users interact with the web page the DOM publishes these interactions as events, for example  click ,  scroll ,  keypress , and  more .  After selecting an element from the DOM, we can call its  addEventListener  method which will execute a callback function we provide any time that event occurs. Lets start by listening for a  click  on the  document  and trigger an  alert  whenever the user clicks anywhere on the page.  We are going to keep working in the dev console for now, and continue to mess around. Once we get the hang of event handlers, we can start building our app. But for now, let's just keep using the dev console.  var handler = function() {\n  alert('user clicked on the page')\n}\n\ndocument.addEventListener('click', handler)  Now if you click on the page you should receive an alert with your message. Alerting users every time they click the page can get annoying so lets remove that event listener.  document.removeEventListener('click', handler)  It's important to note that in order for us to be able to remove an event listener we need to keep a reference to our functions so we can specify which listener function to remove.  Using this simple API we can trigger the complex logic we will be writing shortly.", 
            "title": "Event handling"
        }, 
        {
            "location": "/dom/#multiple-event-listeners", 
            "text": "One of the great things about event listeners is that we can attach multiple listeners per event. For example:  var handlerOne = function() {\n  // Do some logic\n}\n\nvar handlerTwo = function() {\n  // Do some logic\n}\n\ndocument.addEventListener('click', handlerOne)\ndocument.addEventListener('click', handlerTwo)  Now both of these functions will be executed whenever someone clicks the page.", 
            "title": "Multiple event listeners"
        }, 
        {
            "location": "/dom/#event-listener-argument", 
            "text": "When we attach callback functions to events these functions are passed as an event argument. The type of event given will change depending on the type of input device which triggered it. Since we are listening for a  click  event we will receive a  MouseEvent .  var logEvent = function(evt) {\n  console.log(evt)\n}\n\ndocument.addEventListener('click', logEvent)  If you inspect this event in the console you will see there are quite a few properties available to us. The ones most commonly used are  target  and  currentTarget .  target  is the element that dispatched the event.  currentTarget  is the element that handled the event during the event capture (a.k.a bubbling) phase.  Although important, we won't dive into the distinction between these two just yet. We will be using the  currentTarget  property to get a reference to the element that is listened to this event.", 
            "title": "Event listener argument"
        }, 
        {
            "location": "/manipulate/", 
            "text": "Add and remove skills\n\n\nNow that we have learned about the DOM and used the console inside of our browser to get the hang of event handlers, let's create a new JavaScript file and start building our app.\n\n\nYou might remember that our build tool, Gulp, will compile any \n.js\n files that we put in the \napp\n directory into a single \nindex.js\n file and Gulp outputs this file in the \npublic\n directory.  You should leave all the files in \npublic\n alone and let the build tool manage creating these files.\n\n\nThere is also a script tag in the \nindex.html\n file to load all of your scripts, our Gulp script will create a copy of the \nindex.html\n in the public folder, which should also not be worked on directly.  You will will be updating the files in the \napp\n folder.  Let's begin by creating a new file \napp.js\n inside of the \napp\n directory.\n\n\nWith that in place, we can now begin to add more functionality to our form. We have more than just a single skill to boast about, so we want to be able to add multiple skills. We may also change our mind while we're filling out the form so we will have to be able to remove a skill, also.\n\n\nAdding a skill\n\n\nYou probably noticed the nice \n+\n button next to the \nskills\n input. Right now it doesn't do anything. We need to add a \nclick\n handler in order to bring it to life.\n\n\nIn order to do that, we need to first select the \n.add-skill\n button which we will attach the handler to and then we need to also have a \"blueprint\" of the original div containing the skill elements so that we can copy it when we add another one.  Let's add this to our \napp.js\n file:\n\n\nvar addSkillButton = document.querySelector('.add-skill')\nvar skillTemplate = document.querySelector('.skill')\n\nfunction addSkillHandler(evt) {\n  alert('adding skill')\n}\naddSkillButton.addEventListener('click', addSkillHandler)\n\n\n\n\nIf you give this a try in your browser now, you'll see the alert pop up when you click on the plus.\n\n\nWhat does \"add skill\" really mean? We want to duplicate the skill blueprint we have, \nskillTemplate\n, and create another node just like it. Then, we want to append it at the end of the list of skills.\n\n\nWe can clone any DOM node with the \ncloneNode\n method. The \ncloneNode\n method takes an optional boolean argument to determine whether it should be a deep or shallow clone. Since we want the entire \ninput-group\n element and all of its children nodes, we are going to pass a \ntrue\n in.\n\n\nUnfortunately, there is no \nappendAfter\n method we can use, but there is an \ninsertBefore\n method. We can use \ninsertBefore\n to append the new cloned node just before the submit button.\n\n\nThe \ninsertBefore\n method uses a handle on the parent node to attach the new node in the correct spot within the tree. We can use the \nparentNode\n accessor on any DOM node to get its parent. Alternatively, since we know the parent is the form, we can just directly select it again.\n\n\nvar addSkillButton = document.querySelector('.add-skill')\nvar skillTemplate = document.querySelector('.skill').cloneNode(true)\n\nfunction addSkillHandler(evt) {\n  var submitNode = document.querySelector('.submit')\n  var form = submitNode.parentNode\n  var newSkill = skillTemplate.cloneNode(true)\n  form.insertBefore(newSkill, submitNode)\n}\naddSkillButton.addEventListener('click', addSkillHandler)\n\n\n\n\nWe just grew a branch on our DOM tree \ud83c\udf33! Does it look right, though?\n\n\n\n\nAfter we clone a new node, we need to change the plus sign to a minus sign on the previous one. If you look at the \napp/index.html\n file you'll see that both the plus and minus icons already exist in the DOM, except that the minus is currently hidden with the class \nhidden\n.\n\n\nIt would be useful to be able to select the last element in a group. Let's write a helper method that does just that for a given selector.\n\n\nfunction last(selector) {\n  var all = document.querySelectorAll(selector)\n  var length = all.length\n  return all[length - 1]\n}\n\n\n\n\nNow let's update our \naddSkillHandler\n method to get a handle on the previous skill, update it to show the minus instead of the plus, and \nthen\n add the new skill to the end of the list.\n\n\nWhen we have a handle on the DOM node as we will with the previous skill, we can get a list of the node's classes by using the \nclassList\n accessor\n. We can then use \n.add()\n and \n.remove()\n methods to add and remove classes from this node.\n\n\nvar addSkillButton = document.querySelector('.add-skill')\nvar skillTemplate = document.querySelector('.skill').cloneNode(true)\n\nfunction addSkillHandler(evt) {\n  var prevSkill = last('.skill')\n  var newSkill = skillTemplate.cloneNode(true)\n  var submitNode = document.querySelector('.submit')\n  var form = submitNode.parentNode\n\n  prevSkill.querySelector('.add-skill').classList.add('hidden')\n  prevSkill.querySelector('.remove-skill').classList.remove('hidden')\n\n  form.insertBefore(newSkill, submitNode)\n}\naddSkillButton.addEventListener('click', addSkillHandler)\n\n\n\n\nIf you head over to the browser, the first + button should work! Sweet DOM manipulation.\n\n\nDid you try to click the second plus button like a smarty pants? It didn't work, right?\n\n\nLet's fix it by attaching the handler to the new element as well.\n\n\nvar addSkillButton = document.querySelector('.add-skill')\nvar skillTemplate = document.querySelector('.skill').cloneNode(true)\n\nfunction addSkillHandler(evt) {\n  var prevSkill = last('.skill')\n  var newSkill = skillTemplate.cloneNode(true)\n  var submitNode = document.querySelector('.submit')\n  var form = submitNode.parentNode\n\n  prevSkill.querySelector('.add-skill').classList.add('hidden')\n  prevSkill.querySelector('.remove-skill').classList.remove('hidden')\n\n  newSkill.querySelector('.add-skill').addEventListener('click', addSkillHandler)\n\n  form.insertBefore(newSkill, submitNode)\n}\naddSkillButton.addEventListener('click', addSkillHandler)\n\n\n\n\nGreat, now you're ready to remove some skills!\n\n\nRemoving a skill\n\n\nMuch like we created an event handler for adding a skill, we will now create one to remove a skill.\n\n\nvar removeSkillHandler = function(evt) {}\n\n\n\n\nWhen the minus button is clicked the minus button element becomes the \ncurrentTarget\n on the event object passed in as the first argument to our handler.\n\n\nIf we have a handle on the minus button, then we can select the \nparentNode\n to get the group of elements that makes up a single skill. And if we can do that, then we can call \nremove()\n do remove the node from the DOM.\n\n\nvar removeSkillButton = document.querySelector('.remove-skill')\n\nfunction removeSkillHandler(evt) {\n  var skill = evt.currentTarget.parentNode\n  skill.remove()\n}\n\nremoveSkillButton.addEventListener('click', removeSkillHandler)\n\n\n\n\nWe will also need to bind the \nremoveSkillHandler\n to our new \n.remove-skill\n elements.\n\n\nvar addSkillButton = document.querySelector('.add-skill')\nvar skillTemplate = document.querySelector('.skill').cloneNode(true)\n\nfunction addSkillHandler(evt) {\n  var prevSkill = last('.skill')\n  var newSkill = skillTemplate.cloneNode(true)\n  var submitNode = document.querySelector('.submit')\n  var form = submitNode.parentNode\n\n  prevSkill.querySelector('.add-skill').classList.add('hidden')\n  prevSkill.querySelector('.remove-skill').classList.remove('hidden')\n\n  newSkill.querySelector('.add-skill').addEventListener('click', addSkillHandler)\n  newSkill.querySelector('.remove-skill').addEventListener('click', removeSkillHandler)\n\n  form.insertBefore(newSkill, submitNode)\n}\naddSkillButton.addEventListener('click', addSkillHandler)", 
            "title": "Manipulating the DOM"
        }, 
        {
            "location": "/manipulate/#add-and-remove-skills", 
            "text": "Now that we have learned about the DOM and used the console inside of our browser to get the hang of event handlers, let's create a new JavaScript file and start building our app.  You might remember that our build tool, Gulp, will compile any  .js  files that we put in the  app  directory into a single  index.js  file and Gulp outputs this file in the  public  directory.  You should leave all the files in  public  alone and let the build tool manage creating these files.  There is also a script tag in the  index.html  file to load all of your scripts, our Gulp script will create a copy of the  index.html  in the public folder, which should also not be worked on directly.  You will will be updating the files in the  app  folder.  Let's begin by creating a new file  app.js  inside of the  app  directory.  With that in place, we can now begin to add more functionality to our form. We have more than just a single skill to boast about, so we want to be able to add multiple skills. We may also change our mind while we're filling out the form so we will have to be able to remove a skill, also.", 
            "title": "Add and remove skills"
        }, 
        {
            "location": "/manipulate/#adding-a-skill", 
            "text": "You probably noticed the nice  +  button next to the  skills  input. Right now it doesn't do anything. We need to add a  click  handler in order to bring it to life.  In order to do that, we need to first select the  .add-skill  button which we will attach the handler to and then we need to also have a \"blueprint\" of the original div containing the skill elements so that we can copy it when we add another one.  Let's add this to our  app.js  file:  var addSkillButton = document.querySelector('.add-skill')\nvar skillTemplate = document.querySelector('.skill')\n\nfunction addSkillHandler(evt) {\n  alert('adding skill')\n}\naddSkillButton.addEventListener('click', addSkillHandler)  If you give this a try in your browser now, you'll see the alert pop up when you click on the plus.  What does \"add skill\" really mean? We want to duplicate the skill blueprint we have,  skillTemplate , and create another node just like it. Then, we want to append it at the end of the list of skills.  We can clone any DOM node with the  cloneNode  method. The  cloneNode  method takes an optional boolean argument to determine whether it should be a deep or shallow clone. Since we want the entire  input-group  element and all of its children nodes, we are going to pass a  true  in.  Unfortunately, there is no  appendAfter  method we can use, but there is an  insertBefore  method. We can use  insertBefore  to append the new cloned node just before the submit button.  The  insertBefore  method uses a handle on the parent node to attach the new node in the correct spot within the tree. We can use the  parentNode  accessor on any DOM node to get its parent. Alternatively, since we know the parent is the form, we can just directly select it again.  var addSkillButton = document.querySelector('.add-skill')\nvar skillTemplate = document.querySelector('.skill').cloneNode(true)\n\nfunction addSkillHandler(evt) {\n  var submitNode = document.querySelector('.submit')\n  var form = submitNode.parentNode\n  var newSkill = skillTemplate.cloneNode(true)\n  form.insertBefore(newSkill, submitNode)\n}\naddSkillButton.addEventListener('click', addSkillHandler)  We just grew a branch on our DOM tree \ud83c\udf33! Does it look right, though?   After we clone a new node, we need to change the plus sign to a minus sign on the previous one. If you look at the  app/index.html  file you'll see that both the plus and minus icons already exist in the DOM, except that the minus is currently hidden with the class  hidden .  It would be useful to be able to select the last element in a group. Let's write a helper method that does just that for a given selector.  function last(selector) {\n  var all = document.querySelectorAll(selector)\n  var length = all.length\n  return all[length - 1]\n}  Now let's update our  addSkillHandler  method to get a handle on the previous skill, update it to show the minus instead of the plus, and  then  add the new skill to the end of the list.  When we have a handle on the DOM node as we will with the previous skill, we can get a list of the node's classes by using the  classList  accessor . We can then use  .add()  and  .remove()  methods to add and remove classes from this node.  var addSkillButton = document.querySelector('.add-skill')\nvar skillTemplate = document.querySelector('.skill').cloneNode(true)\n\nfunction addSkillHandler(evt) {\n  var prevSkill = last('.skill')\n  var newSkill = skillTemplate.cloneNode(true)\n  var submitNode = document.querySelector('.submit')\n  var form = submitNode.parentNode\n\n  prevSkill.querySelector('.add-skill').classList.add('hidden')\n  prevSkill.querySelector('.remove-skill').classList.remove('hidden')\n\n  form.insertBefore(newSkill, submitNode)\n}\naddSkillButton.addEventListener('click', addSkillHandler)  If you head over to the browser, the first + button should work! Sweet DOM manipulation.  Did you try to click the second plus button like a smarty pants? It didn't work, right?  Let's fix it by attaching the handler to the new element as well.  var addSkillButton = document.querySelector('.add-skill')\nvar skillTemplate = document.querySelector('.skill').cloneNode(true)\n\nfunction addSkillHandler(evt) {\n  var prevSkill = last('.skill')\n  var newSkill = skillTemplate.cloneNode(true)\n  var submitNode = document.querySelector('.submit')\n  var form = submitNode.parentNode\n\n  prevSkill.querySelector('.add-skill').classList.add('hidden')\n  prevSkill.querySelector('.remove-skill').classList.remove('hidden')\n\n  newSkill.querySelector('.add-skill').addEventListener('click', addSkillHandler)\n\n  form.insertBefore(newSkill, submitNode)\n}\naddSkillButton.addEventListener('click', addSkillHandler)  Great, now you're ready to remove some skills!", 
            "title": "Adding a skill"
        }, 
        {
            "location": "/manipulate/#removing-a-skill", 
            "text": "Much like we created an event handler for adding a skill, we will now create one to remove a skill.  var removeSkillHandler = function(evt) {}  When the minus button is clicked the minus button element becomes the  currentTarget  on the event object passed in as the first argument to our handler.  If we have a handle on the minus button, then we can select the  parentNode  to get the group of elements that makes up a single skill. And if we can do that, then we can call  remove()  do remove the node from the DOM.  var removeSkillButton = document.querySelector('.remove-skill')\n\nfunction removeSkillHandler(evt) {\n  var skill = evt.currentTarget.parentNode\n  skill.remove()\n}\n\nremoveSkillButton.addEventListener('click', removeSkillHandler)  We will also need to bind the  removeSkillHandler  to our new  .remove-skill  elements.  var addSkillButton = document.querySelector('.add-skill')\nvar skillTemplate = document.querySelector('.skill').cloneNode(true)\n\nfunction addSkillHandler(evt) {\n  var prevSkill = last('.skill')\n  var newSkill = skillTemplate.cloneNode(true)\n  var submitNode = document.querySelector('.submit')\n  var form = submitNode.parentNode\n\n  prevSkill.querySelector('.add-skill').classList.add('hidden')\n  prevSkill.querySelector('.remove-skill').classList.remove('hidden')\n\n  newSkill.querySelector('.add-skill').addEventListener('click', addSkillHandler)\n  newSkill.querySelector('.remove-skill').addEventListener('click', removeSkillHandler)\n\n  form.insertBefore(newSkill, submitNode)\n}\naddSkillButton.addEventListener('click', addSkillHandler)", 
            "title": "Removing a skill"
        }, 
        {
            "location": "/ajax/", 
            "text": "Add submit event\n\n\nNow that we've covered the basics of getting a DOM element and hooking into its events, let's add a submit event handler to the form. Later, we'll use this handler to kick off a request to the backend.\n\n\nOur first step in the \napp.js\n file we created previously is to get a reference to the form element. Create a variable named \nform\n, and assign the form DOM element on the page to it.\n\n\nvar form = document.querySelector('form')\n\n\n\n\nOn the next line create a \nsubmitHandler\n function. We will need to have the event passed into the handler available to us so add the parameter \nevt\n to the function declaration.\n\n\nvar submitHandler = function(evt) {}\n\n\n\n\nWe will be using the \npreventDefault\n method on the event object. This handy method will stop the form from submitting to the backend so that we can submit this information using AJAX.\n\n\nLet's also throw in an \nalert\n so that we can see some feedback from the submit handler. Otherwise, when we click on the submit button nothing will happen which can be confusing. Add the two new commands to the submit handler declaration like below.\n\n\nvar submitHandler = function(evt) {\n  evt.preventDefault()\n  alert('submit!')\n}\n\n\n\n\nIn order to hook this handler up to our form element, we will need to use the \naddEventListener\n method that exists on the form node. Pass in \nsubmit\n as the event we want to listen for and pass in the custom handler we just wrote.\n\n\nform.addEventListener('submit', submitHandler)\n\n\n\n\nNow if you refresh the page you should be able to submit the form after filling out the two required fields, but instead of the page refreshing and losing everything you've entered the page will show you an alert and you won't lose any of the information you typed.\n\n\nOur event handler is now working!\n\n\nSerialize the form data\n\n\nBefore we can begin to assemble the pieces for talking to our server, we will need to make sure that we can capture the data from our form in a format that our API endpoint can digest. The API for this workshop is built with \nrails-api\n which will be expecting a JSON object on the request.\n\n\nWe need to take the form data and convert it to an object that looks like this\n\n\n{\n  \nform\n: {\n    \nname\n: \n,\n    \nemail\n: \n,\n    \ncity\n: \n,\n    \nstate\n: \n,\n    \ngithub\n: \n,\n    \ntwitter\n: \n,\n    \nbio\n: \n,\n    \nskills_attributes\n: []\n  }\n}\n\n\n\n\nLet's write a \nserializeArray\n method to take our form data and turn it into the serialized JSON data object.\n\n\nvar serializeArray = function(selector) {}\n\n\n\n\nWe want to be able to pass in our selector for the form to this method and get the JSON object back. First, let's use \ndocument.querySelector\n again to grab the form.\n\n\nvar serializeArray = function(selector) {\n  var form = document.querySelector(selector)\n}\n\n\n\n\nProTip\u2122:\n  In our example, we know we are passing in a form selector but if you wanted to use this method in a different scenario, you might want to check that the element we have selected is actually a form by using \nform.tagName\n to check the element's tag name.\n\n\nNow we need to grab all the inputs from inside the form element. Remember the \nquerySelectorAll\n method mentioned above? While \nquerySelector\n returns a single Node in the DOM, \nquerySelectorAll\n will return a \nNodeList\n.\n\n\nThe unusual thing about this is that \nNodeList\n is not a JavaScript \nArray\n and so we cannot use methods like \nmap\n or \nforEach\n to iterate over the items returned. We could do some fancy work and add these methods to the prototype for \nNodeList\n, but to keep things simple we will just use a basic \nfor\n loop to iterate over them.\n\n\nvar serializeArray = function(selector) {\n  var form = document.querySelector(selector)\n  var formInputs = form.querySelectorAll('input,textarea')\n\n  for (var i = 0; i \n formInputs.length; i++) {\n    var item = formInputs[i]\n  }\n}\n\n\n\n\nNow that we can iterate over them we will need to store the \nname\n and \nvalue\n of each item onto a JSON object as the \nkey\n,\nvalue\n pair. When we are accessing the \nNode\n directly, we can easily call \nnode.name\n or \nnode.value\n to access these attributes.\n\n\nWe can't test our method unless we call our \nserializeArray\n method from somewhere, so let's add the call into our \nsubmitHandler\n method.\n\n\nvar submitHandler = function(evt) {\n  evt.preventDefault()\n  var data = serializeArray('form')\n}\n\n\n\n\nOk, now let's build our final \ndata\n JSON object. Let's also log it to the console so that we can inspect it make sure it matches our expected output that we defined above.\n\n\nvar serializeArray = function(selector) {\n  var form = document.querySelector(selector)\n  var formInputs = form.querySelectorAll('input,textarea')\n\n  // Empty object for us to set key values of inputs\n  var data = {}\n\n  for (var i = 0; i \n formInputs.length; i++) {\n    var item = formInputs[i]\n    data[item.name] = item.value\n  }\n\n  // Log out our final object so we can inspect it\n  console.log(data)\n}\n\n\n\n\nWhen you reload the page and submit the form again, you should see something similar to this outputted in the console.\n\n\n\n\nWell that looks \nnearly\n correct. Can you spot the problems?\n\n\nFirstly, we're capturing the submit button. There are a couple ways to avoid this.\n\n\nWe could change the submit button from an \ninput\n to a \ndiv\n and change our handler from the \nform\n \nsubmit\n event to the \ndiv\n \nonclick\n event. If we were to do this, we would lose the native validations, so let's nix this idea.\n\n\nWe could instead just change our \nquerySelectorAll(...)\n selector string to ignore the \ntype=submit\n input. That seems simple enough, so let's add that in.\n\n\nvar serializeArray = function(selector) {\n  var form = document.querySelector(selector)\n  var formInputs = form.querySelectorAll('input:not([type=submit]),textarea')\n\n  // Empty object for us to set key values of inputs\n  var data = {}\n\n  for (var i = 0; i \n formInputs.length; i++) {\n    var item = formInputs[i]\n    data[item.name] = item.value\n  }\n\n  // Log out our final object so we can inspect it\n  console.log(data)\n}\n\n\n\n\nOk, let's try this again!\n\n\n\n\nSomething is still off. Did you spot it?\n\n\nWe need our \nskills_attributes\n key to have an array value since we have multiple skills. Right now, only the very last skill is being saved. We want to catch this special case inside of our \nfor\n loop. In the \nfor\n loop, test if the current item is \nskills_attributes\n item. If it is, create an array with the current skill. If we have already created the key and value pair, then just append the current skill to the existing array.\n\n\nvar serializeArray = function(selector) {\n  var form = document.querySelector(selector)\n  var formInputs = form.querySelectorAll('input:not([type=submit]),textarea')\n\n  // Empty object for us to set key values of inputs\n  var data = {}\n\n  for (var i = 0; i \n formInputs.length; i++) {\n    var item = formInputs[i]\n\n    if (item.name === 'skills_attributes') {\n      if (!!data[item.name]) {\n        data[item.name].push({'description': item.value})\n      } else {\n        data[item.name] = [{'description': item.value}]\n      }\n    } else {\n      data[item.name] = item.value\n    }\n  }\n\n  // Log out our final object so we can inspect it\n  console.log(data)\n}\n\n\n\n\nHead back over to the console, and you'll see our data now looks correct! We can now replace the \nconsole.log\n with a \nreturn\n statement to pass the output back.\n\n\nWe also want to package up the data for the backend request. The backend expects to find all of this data we're working with in a wrapper. The wrapper has one key and value pair. We'll set the key with the form's name which we pull form from it's DOM node and set the value to the data object we've been building. Place this after the \nfor\n loop and before the \nreturn\n statement.\n\n\nvar serializeArray = function(selector) {\n  var form = document.querySelector(selector)\n  var formInputs = form.querySelectorAll('input:not([type=submit]),textarea')\n\n  // Empty object for us to set key values of inputs\n  var data = {}\n\n  for (var i = 0; i \n formInputs.length; i++) {\n    var item = formInputs[i]\n\n    if (item.name === 'skills_attributes') {\n      if (!!data[item.name]) {\n        data[item.name].push({'description': item.value})\n      } else {\n        data[item.name] = [{'description': item.value}]\n      }\n    } else {\n      data[item.name] = item.value\n    }\n  }\n\n  var wrapper = {};\n  wrapper[form.name] = data;\n\n  return wrapper\n}\n\n\n\n\nBuild XHR and submit\n\n\nNow that we have our data we need to send it to the server using an XHR or \nXMLHttpRequest\n. This allows us to communicate with the server without changing pages, and then do some action based on the data we get back. We are going to create a function that we can put in our event handlers that will do this.\n\n\nvar xhr = function(method, path, data, callback) {}\n\n\n\n\nFirst, we create a new instance of XHR.\n\n\nvar xhr = function(method, path, data, callback) {\n  var request = new XMLHttpRequest()\n}\n\n\n\n\nNext we'll use \nopen(method, path, async)\n to initialize the request.\n\n\n\n\nmethod:\n a string of an HTTP method to use, such as 'GET', 'POST', 'PUT', 'DELETE'. This will match the Verb on the API table up top.\n\n\npath:\n a string of the full path to send the request to. This will include the API endpoint URL as well as the path.\n\n\nasync:\n a boolean flag that dictates whether the script should run asynchronously.\n\n\n\n\nProTip\u2122:\n \nasync\n should always be \ntrue\n to prevent blocking. Stopping JavaScript execution especially hurts time sensitive things like rendering or event listening/handling.\n\n\nvar xhr = function(method, path, data, callback) {\n  var request = new XMLHttpRequest()\n  request.open(method, path, true)\n}\n\n\n\n\nBecause we'll be using a JSON endpoint any requests we make to it should contain a \nContent-Type\n header.\n\n\nvar xhr = function(method, path, data, callback) {\n  var request = new XMLHttpRequest()\n  request.open(method, path, true)\n  request.setRequestHeader('Content-Type', 'application/json')\n}\n\n\n\n\nXHR only has one event we care to listen to and that's \nonreadystatechange\n.\n\n\nThe ready state of the XHR will change a few times, but we are looking for the last state of \n4\n which is triggered when the request operation is complete.\n\n\nWe'll also check to make sure we got a good server response. If it passes those checks, we'll parse the response JSON, then send the object back though a callback.\n\n\nvar xhr = function(method, path, data, callback) {\n  var request = new XMLHttpRequest()\n  request.open(method, path, true)\n  request.setRequestHeader('Content-Type', 'application/json')\n  request.onreadystatechange = function() {\n    // ignore anything that isn't the last state\n    if (request.readyState !== 4) { return }\n\n    // if we didn't get a \ngood\n status such as 200 OK or 201 Created send back an error\n    if (request.readyState === 4 \n (request.status !== 200 \n request.status !== 201)) {\n      callback(new Error('XHR Failed: ' + path), null)\n    }\n\n    // return our server data\n    callback(null, JSON.parse(request.responseText))\n  }\n}\n\n\n\n\nLastly we will use \nJSON.stringify\n to convert our object to a JSON string and send the request with our data using the \nsend\n function. \nJSON.stringify\n is helper method that serializes a JavaScript object into the \nJSON\n format. It's main purpose is for packaging up data to be sent in an AJAX request. In the next section we'll make the AJAX request!\n\n\nvar xhr = function(method, path, data, callback) {\n  var request = new XMLHttpRequest()\n  request.open(method, path, true)\n  request.setRequestHeader('Content-Type', 'application/json')\n  request.onreadystatechange = function() {\n    // ignore anything that isn't the last state\n    if (request.readyState !== 4) { return }\n\n    // if we didn't get a \ngood\n status such as 200 OK or 201 Created send back an error\n    if (request.readyState === 4 \n (request.status !== 200 \n request.status !== 201)) {\n      callback(new Error('XHR Failed: ' + path), null)\n    }\n\n    // return our server data\n    callback(null, JSON.parse(request.responseText))\n  }\n  request.send(JSON.stringify(data))\n}\n\n\n\n\nNow we're ready to use it inside of our \nsubmitHandler\n. We can call it with the 'POST' method and pass it the form data.\n\n\nvar apiURL = '//sandiegojs-vanilla-workshop.herokuapp.com'\n\nvar submitHandler = function(evt) {\n  evt.preventDefault()\n  var path = apiURL + '/forms'\n  xhr('POST', path, serializeArray('form'), function(err, data) {\n    if (err) { throw err }\n    console.log(data)\n  })\n}\n\n\n\n\nHandle server response\n\n\nCongratulations! We can now submit the form to the server and get a response. Now let's do something with the response.\n\n\nWe're going to write any errors from our XHR request to the screen. We're also going to render the contents of the form to the screen if it was successfully submitted.\n\n\nSome of the methods we'll be using are:\n\n\n\n\nDocument.createElement\n this method creates a DOM element of the type specified in the first parameter. For example, we can pass in \ndiv\n, \np\n, \nul\n, etc.\n\n\nDocument.createTextNode\n this method creates a text node that can be placed in the document. We'll use this to hold content we author.\n\n\nNode.appendChild\n this method can be called on any element created using createElement. As you can guess from the name it adds the node passed in to the end of node you call appendChild on.\n\n\n\n\nLet's create a small helper function. It creates a DOM node and adds some text to it. We're going to be making a lot calls to this.\n\n\nvar createElementWithTextNode = function(tagName, tagContent) {}\n\n\n\n\nRight inside of that function declaration we should add a call to \ndocument.createElement\n.\n\n\nvar createElementWithTextNode = function(tagName, tagContent) {\n  var node = document.createElement(tagName)\n}\n\n\n\n\nNext up we will create a text node that will hold whatever is inside of the tagContent variable.\n\n\nvar createElementWithTextNode = function(tagName, tagContent) {\n  var node = document.createElement(tagName)\n  var textNode = document.createTextNode(tagContent)\n}\n\n\n\n\nThen we combine the two freshly created nodes. You can add other HTML nodes or text nodes to a node even if the HTML node would usually have children, such as \nbr\n.\n\n\nvar createElementWithTextNode = function(tagName, tagContent) {\n  var node = document.createElement(tagName)\n  var textNode = document.createTextNode(tagContent)\n  node.appendChild(textNode)\n}\n\n\n\n\nThere is a possibility that when we call this function we won't have any textContent, and calling \ndocument.createTextNode\n without textContent will cause an error. To avoid this kind of error wrap the creation and insertion of the textNode in a conditional test for textContent.\n\n\nvar createElementWithTextNode = function(tagName, tagContent) {\n  var node = document.createElement(tagName)\n  if (tagContent) {\n    var textNode = document.createTextNode(tagContent)\n    node.appendChild(textNode)\n  }\n}\n\n\n\n\nAnd lastly we will return the node we created with a child text node.\n\n\nvar createElementWithTextNode = function(tagName, tagContent) {\n  var node = document.createElement(tagName)\n  if (tagContent) {\n    var textNode = document.createTextNode(tagContent)\n    node.appendChild(textNode)\n  }\n  return node\n}\n\n\n\n\nNow that we have that built, we can start to output some content. First create the renderError function\n\n\nvar renderError = function(error) {}\n\n\n\n\nThe error render will be very simple. We are going to get a reference to the response container, create a node with our helper function, add a custom class to it, and append it to the document.\n\n\nvar renderError = function(error) {\n  var responseNode = document.querySelector('.response-wrapper')\n  var errorNode = createElementWithTextNode('div', error.toString())\n  errorNode.className = 'error'\n  responseNode.appendChild(errorNode)\n}\n\n\n\n\nNow it's time to create the renderFormData function. This function is going to create many DOM nodes and append them to the response container.\n\n\nvar renderFormData = function(data) {}\n\n\n\n\nThe first thing we want to do inside of the renderFormData function is get a reference to the response container just like in our \nrenderError\n function.\n\n\nvar renderFormData = function(data) {\n  var responseNode = document.querySelector('.response-wrapper')\n}\n\n\n\n\nNow, let's create a generic success message so we can see on screen when the form was submitted and the backend saved it.\n\n\nvar renderFormData = function(data) {\n  var responseNode = document.querySelector('.response-wrapper')\n\n  //generic success message\n  var successNode = createElementWithTextNode('div', 'You\\'ve add a new card')\n  successNode.className = 'success'\n  responseNode.appendChild(successNode)\n}\n\n\n\n\nGreat, now we can give some kind of feedback to the user when the form is successfully processed by backend or not. Let's improve upon this, though. Let's show the information we entered when we submitted so we can verify it saved properly.\n\n\nTo do this we'll create a dictionary list, and fill it with all the some of the information that is returned by the request.\n\n\nLet's use the \ndocument.createElement\n method to create a DL node that will hold all those terms and definitions. Append this to the \nrenderFormData\n function.\n\n\nvar dictionaryNode = document.createElement('dl')\n\n\n\n\nThe next step is to add some terms and definitions. Let's use the \ncreateElementWithTextNode\n helper function to streamline the process of printing out the name. Add the next couple of lines after the \ndictionaryNode\n variable declaration and assignment.\n\n\n//create a dom node with the name of a value\nvar termNode = createElementWithTextNode('dt', 'name')\ndictionaryNode.appendChild(termNode)\n\n//create another dom node with the value\nvar definitionNode = createElementWithTextNode('dd', data.name)\ndictionaryNode.appendChild(definitionNode)\n\n\n\n\nNow, after the success message we're printing out the name we entered on the form. This response would be more useful if we showed more information. It would be good to show the name, email, and some other attributes. The simplest way to do this is to just copy and paste the code we just wrote and swap out name for email, github, etc.\n\n\nBut, there's a better way. If we create a list of keys we'd like to show on screen, we can loop through them with the native \nforEach\n method of an array. This method will iterate over an array and call a passed in callback function for each item in the array. The first parameter of the callback will be the current item that forEach is iterating through.\n\n\nCreate an array called keys. Place it just after the insertion of the success message, but keep it before the last set of statements we wrote.\n\n\nvar keys = ['name', 'email', 'github', 'twitter', 'city', 'state', 'bio']\n\n\n\n\nNext call the \nforEach\n method on it and pass in an \nanonymous function\n with a single parameter of \nkey\n.\n\n\nkeys.forEach(function(key) {})\n\n\n\n\nMove the name definition and insertion we wrote earlier into the callback. Change the text passed into \ncreateElementWithTextNode\n. For the first call replace the string literal, \n'name'\n with the variable \nkey\n, and for the second call replace \ndata.name\n with \ndata[key]\n. This will allow each iteration to print the current key, such as name or email, as the dictionary term and the actual value, such as \"John Doe\", will be the dictionary definition.\n\n\nkeys.forEach(function(key) {\n  //create a dom node with the name of a value\n  var termNode = createElementWithTextNode('dt', key)\n  dictionaryNode.appendChild(termNode)\n\n  //create another dom node with the value\n  var definitionNode = createElementWithTextNode('dd', data[key])\n  dictionaryNode.appendChild(definitionNode)\n})\n\n\n\n\nIf you review the array of keys we're looping through, you'll notice we didn't include \nskills\n like we did when we posted the data. That's because the content of that property is more complex than the simple strings of the other properties. If we want to print them out we'll have to write some custom logic.\n\n\nCreate a new dictionary term node like we do in the \nforEach\n callback, but set the text content to \"skills\".\n\n\nvar skillsTermNode = createElementWithTextNode('dt', 'skills')\ndictionaryNode.appendChild(skillsTermNode)\n\n\n\n\nLet's add the dictionary definition, now. We'll add the actual skills information in the next step. We'll show all the skills as a list, so let's also add a \nUL\n node as well and store a reference to it in a variable so we can add \nLI\n elements to it later.\n\n\nvar skillsDefinitionNode = document.createElement('dd')\nvar skillsList = document.createElement('ul')\nskillsDefinitionNode.appendChild(skillsList)\ndictionaryNode.appendChild(skillsDefinitionNode)\n\n\n\n\nNow that that's out of the way, let's loop through each skill we received, if any, and combine them into one dictionary definition. To accomplish this we'll test to see if there is any value stored in \nskills_attributes\n. If there is then we can loop through all the skills by using the \nforEach\n method to loop through each complex element in the array and append a simpler set of information to the dictionary. In our case, we'll append only the description of each skill wrapped in a \nLI\n tag.\n\n\nif (data.skills_attributes) {\n  data.skills_attributes_.forEach(function (skill) {\n    var skillNode = createElementWithTextNode('li', skill.description)\n    skillsList.appendChild(skillNode)\n  })\n}\n\n\n\n\nThe last steps are to add a custom class of \nresponse\n and append the dictionaryNode we've been populating to the responseNode from the beginning of the function. Here is the entire \nrenderFormData\n function:\n\n\nvar renderFormData = function(data) {\n  var responseNode = document.querySelector('.response-wrapper')\n\n  //generic success message\n  var successNode = createElementWithTextNode('div', 'You\\'ve add a new card')\n  successNode.className = 'success'\n  responseNode.appendChild(successNode)\n\n  var dictionaryNode = document.createElement('dl')\n  var keys = ['name', 'email', 'github', 'twitter', 'city', 'state', 'bio']\n  keys.forEach(function(key) {\n    //create a dom node with the name of a value\n    var termNode = createElementWithTextNode('dt', key)\n    dictionaryNode.appendChild(termNode)\n\n    //create another dom node with the value\n    var definitionNode = createElementWithTextNode('dd', data[key])\n    dictionaryNode.appendChild(definitionNode)\n  })\n\n  var skillsTermNode = createElementWithTextNode('dt', 'skills')\n  dictionaryNode.appendChild(skillsTermNode)\n\n  var skillsDefinitionNode = document.createElement('dd')\n  var skillsList = document.createElement('ul')\n  skillsDefinitionNode.appendChild(skillsList)\n  dictionaryNode.appendChild(skillsDefinitionNode)\n\n  if (data.skills_attributes) {\n    data.skills_attributes.forEach(function (skill) {\n      var skillNode = createElementWithTextNode('li', skill.description)\n      skillsList.appendChild(skillNode)\n    })\n  }\n\n  dictionaryNode.className = 'response'\n  responseNode.appendChild(dictionaryNode)\n}\n\n\n\n\nWe've finished creating all the functions we need to process the response from our backend. Let's add \nrenderError\n \n \nrenderFormData\n in the appropriate places in the original submitHandler. In addition, let's reset the form after we know it worked.\n\n\nvar submitHandler = function(evt) {\n  evt.preventDefault()\n  var path = apiURL + '/forms'\n  xhr('POST', path, serializeArray('form'), function(err, data) {\n    if (err) {\n      renderError(err)\n      throw err\n    }\n    console.log(data)\n    renderFormData(data)\n    document.querySelector('form').reset()\n  })\n}\n\n\n\n\nIf you fill out the form, you should see a response similar to what was described in the \nSerialize the form data\n section in your console. For example:\n\n\n{\n  \nid\n: 1,\n  \nname\n: \nTesty McTesterson\n,\n  \nemail\n: \ntest@sandiegojs.org\n,\n  \ncity\n: \nSan Diego\n,\n  \nstate\n: \nCA\n,\n  \ngithub\n: \ntestdev\n,\n  \ntwitter\n: \ntesttwitter\n,\n  \nbio\n: \nLorem Ipsum...\n,\n  \nskills_attributes\n: [\n    {\n      \nid\n: 1,\n      \ndescription\n: \ncooking\n,\n      \nform_id\n: 1,\n      \ncreated_at\n: \n2016-01-21T07:09:01.640Z\n,\n      \nupdated_at\n: \n2016-01-21T07:09:01.640Z\n\n    },\n    {\n      \nid\n: 2,\n      \ndescription\n: \ncleaning\n,\n      \nform_id\n: 1,\n      \ncreated_at\n: \n2016-01-21T07:09:01.640Z\n,\n      \nupdated_at\n: \n2016-01-21T07:09:01.640Z\n\n    }\n  ],\n  \ncreated_at\n: \n2016-01-21T07:09:01.640Z\n,\n  \nupdated_at\n: \n2016-01-21T07:09:01.640Z\n\n}\n\n\n\n\nOn screen you should see the this:\n\n\n\n\nCongratulations! Now we have a fully submitting form that we can use to save people's information.", 
            "title": "AJAX Form Submission"
        }, 
        {
            "location": "/ajax/#add-submit-event", 
            "text": "Now that we've covered the basics of getting a DOM element and hooking into its events, let's add a submit event handler to the form. Later, we'll use this handler to kick off a request to the backend.  Our first step in the  app.js  file we created previously is to get a reference to the form element. Create a variable named  form , and assign the form DOM element on the page to it.  var form = document.querySelector('form')  On the next line create a  submitHandler  function. We will need to have the event passed into the handler available to us so add the parameter  evt  to the function declaration.  var submitHandler = function(evt) {}  We will be using the  preventDefault  method on the event object. This handy method will stop the form from submitting to the backend so that we can submit this information using AJAX.  Let's also throw in an  alert  so that we can see some feedback from the submit handler. Otherwise, when we click on the submit button nothing will happen which can be confusing. Add the two new commands to the submit handler declaration like below.  var submitHandler = function(evt) {\n  evt.preventDefault()\n  alert('submit!')\n}  In order to hook this handler up to our form element, we will need to use the  addEventListener  method that exists on the form node. Pass in  submit  as the event we want to listen for and pass in the custom handler we just wrote.  form.addEventListener('submit', submitHandler)  Now if you refresh the page you should be able to submit the form after filling out the two required fields, but instead of the page refreshing and losing everything you've entered the page will show you an alert and you won't lose any of the information you typed.  Our event handler is now working!", 
            "title": "Add submit event"
        }, 
        {
            "location": "/ajax/#serialize-the-form-data", 
            "text": "Before we can begin to assemble the pieces for talking to our server, we will need to make sure that we can capture the data from our form in a format that our API endpoint can digest. The API for this workshop is built with  rails-api  which will be expecting a JSON object on the request.  We need to take the form data and convert it to an object that looks like this  {\n   form : {\n     name :  ,\n     email :  ,\n     city :  ,\n     state :  ,\n     github :  ,\n     twitter :  ,\n     bio :  ,\n     skills_attributes : []\n  }\n}  Let's write a  serializeArray  method to take our form data and turn it into the serialized JSON data object.  var serializeArray = function(selector) {}  We want to be able to pass in our selector for the form to this method and get the JSON object back. First, let's use  document.querySelector  again to grab the form.  var serializeArray = function(selector) {\n  var form = document.querySelector(selector)\n}  ProTip\u2122:   In our example, we know we are passing in a form selector but if you wanted to use this method in a different scenario, you might want to check that the element we have selected is actually a form by using  form.tagName  to check the element's tag name.  Now we need to grab all the inputs from inside the form element. Remember the  querySelectorAll  method mentioned above? While  querySelector  returns a single Node in the DOM,  querySelectorAll  will return a  NodeList .  The unusual thing about this is that  NodeList  is not a JavaScript  Array  and so we cannot use methods like  map  or  forEach  to iterate over the items returned. We could do some fancy work and add these methods to the prototype for  NodeList , but to keep things simple we will just use a basic  for  loop to iterate over them.  var serializeArray = function(selector) {\n  var form = document.querySelector(selector)\n  var formInputs = form.querySelectorAll('input,textarea')\n\n  for (var i = 0; i   formInputs.length; i++) {\n    var item = formInputs[i]\n  }\n}  Now that we can iterate over them we will need to store the  name  and  value  of each item onto a JSON object as the  key , value  pair. When we are accessing the  Node  directly, we can easily call  node.name  or  node.value  to access these attributes.  We can't test our method unless we call our  serializeArray  method from somewhere, so let's add the call into our  submitHandler  method.  var submitHandler = function(evt) {\n  evt.preventDefault()\n  var data = serializeArray('form')\n}  Ok, now let's build our final  data  JSON object. Let's also log it to the console so that we can inspect it make sure it matches our expected output that we defined above.  var serializeArray = function(selector) {\n  var form = document.querySelector(selector)\n  var formInputs = form.querySelectorAll('input,textarea')\n\n  // Empty object for us to set key values of inputs\n  var data = {}\n\n  for (var i = 0; i   formInputs.length; i++) {\n    var item = formInputs[i]\n    data[item.name] = item.value\n  }\n\n  // Log out our final object so we can inspect it\n  console.log(data)\n}  When you reload the page and submit the form again, you should see something similar to this outputted in the console.   Well that looks  nearly  correct. Can you spot the problems?  Firstly, we're capturing the submit button. There are a couple ways to avoid this.  We could change the submit button from an  input  to a  div  and change our handler from the  form   submit  event to the  div   onclick  event. If we were to do this, we would lose the native validations, so let's nix this idea.  We could instead just change our  querySelectorAll(...)  selector string to ignore the  type=submit  input. That seems simple enough, so let's add that in.  var serializeArray = function(selector) {\n  var form = document.querySelector(selector)\n  var formInputs = form.querySelectorAll('input:not([type=submit]),textarea')\n\n  // Empty object for us to set key values of inputs\n  var data = {}\n\n  for (var i = 0; i   formInputs.length; i++) {\n    var item = formInputs[i]\n    data[item.name] = item.value\n  }\n\n  // Log out our final object so we can inspect it\n  console.log(data)\n}  Ok, let's try this again!   Something is still off. Did you spot it?  We need our  skills_attributes  key to have an array value since we have multiple skills. Right now, only the very last skill is being saved. We want to catch this special case inside of our  for  loop. In the  for  loop, test if the current item is  skills_attributes  item. If it is, create an array with the current skill. If we have already created the key and value pair, then just append the current skill to the existing array.  var serializeArray = function(selector) {\n  var form = document.querySelector(selector)\n  var formInputs = form.querySelectorAll('input:not([type=submit]),textarea')\n\n  // Empty object for us to set key values of inputs\n  var data = {}\n\n  for (var i = 0; i   formInputs.length; i++) {\n    var item = formInputs[i]\n\n    if (item.name === 'skills_attributes') {\n      if (!!data[item.name]) {\n        data[item.name].push({'description': item.value})\n      } else {\n        data[item.name] = [{'description': item.value}]\n      }\n    } else {\n      data[item.name] = item.value\n    }\n  }\n\n  // Log out our final object so we can inspect it\n  console.log(data)\n}  Head back over to the console, and you'll see our data now looks correct! We can now replace the  console.log  with a  return  statement to pass the output back.  We also want to package up the data for the backend request. The backend expects to find all of this data we're working with in a wrapper. The wrapper has one key and value pair. We'll set the key with the form's name which we pull form from it's DOM node and set the value to the data object we've been building. Place this after the  for  loop and before the  return  statement.  var serializeArray = function(selector) {\n  var form = document.querySelector(selector)\n  var formInputs = form.querySelectorAll('input:not([type=submit]),textarea')\n\n  // Empty object for us to set key values of inputs\n  var data = {}\n\n  for (var i = 0; i   formInputs.length; i++) {\n    var item = formInputs[i]\n\n    if (item.name === 'skills_attributes') {\n      if (!!data[item.name]) {\n        data[item.name].push({'description': item.value})\n      } else {\n        data[item.name] = [{'description': item.value}]\n      }\n    } else {\n      data[item.name] = item.value\n    }\n  }\n\n  var wrapper = {};\n  wrapper[form.name] = data;\n\n  return wrapper\n}", 
            "title": "Serialize the form data"
        }, 
        {
            "location": "/ajax/#build-xhr-and-submit", 
            "text": "Now that we have our data we need to send it to the server using an XHR or  XMLHttpRequest . This allows us to communicate with the server without changing pages, and then do some action based on the data we get back. We are going to create a function that we can put in our event handlers that will do this.  var xhr = function(method, path, data, callback) {}  First, we create a new instance of XHR.  var xhr = function(method, path, data, callback) {\n  var request = new XMLHttpRequest()\n}  Next we'll use  open(method, path, async)  to initialize the request.   method:  a string of an HTTP method to use, such as 'GET', 'POST', 'PUT', 'DELETE'. This will match the Verb on the API table up top.  path:  a string of the full path to send the request to. This will include the API endpoint URL as well as the path.  async:  a boolean flag that dictates whether the script should run asynchronously.   ProTip\u2122:   async  should always be  true  to prevent blocking. Stopping JavaScript execution especially hurts time sensitive things like rendering or event listening/handling.  var xhr = function(method, path, data, callback) {\n  var request = new XMLHttpRequest()\n  request.open(method, path, true)\n}  Because we'll be using a JSON endpoint any requests we make to it should contain a  Content-Type  header.  var xhr = function(method, path, data, callback) {\n  var request = new XMLHttpRequest()\n  request.open(method, path, true)\n  request.setRequestHeader('Content-Type', 'application/json')\n}  XHR only has one event we care to listen to and that's  onreadystatechange .  The ready state of the XHR will change a few times, but we are looking for the last state of  4  which is triggered when the request operation is complete.  We'll also check to make sure we got a good server response. If it passes those checks, we'll parse the response JSON, then send the object back though a callback.  var xhr = function(method, path, data, callback) {\n  var request = new XMLHttpRequest()\n  request.open(method, path, true)\n  request.setRequestHeader('Content-Type', 'application/json')\n  request.onreadystatechange = function() {\n    // ignore anything that isn't the last state\n    if (request.readyState !== 4) { return }\n\n    // if we didn't get a  good  status such as 200 OK or 201 Created send back an error\n    if (request.readyState === 4   (request.status !== 200   request.status !== 201)) {\n      callback(new Error('XHR Failed: ' + path), null)\n    }\n\n    // return our server data\n    callback(null, JSON.parse(request.responseText))\n  }\n}  Lastly we will use  JSON.stringify  to convert our object to a JSON string and send the request with our data using the  send  function.  JSON.stringify  is helper method that serializes a JavaScript object into the  JSON  format. It's main purpose is for packaging up data to be sent in an AJAX request. In the next section we'll make the AJAX request!  var xhr = function(method, path, data, callback) {\n  var request = new XMLHttpRequest()\n  request.open(method, path, true)\n  request.setRequestHeader('Content-Type', 'application/json')\n  request.onreadystatechange = function() {\n    // ignore anything that isn't the last state\n    if (request.readyState !== 4) { return }\n\n    // if we didn't get a  good  status such as 200 OK or 201 Created send back an error\n    if (request.readyState === 4   (request.status !== 200   request.status !== 201)) {\n      callback(new Error('XHR Failed: ' + path), null)\n    }\n\n    // return our server data\n    callback(null, JSON.parse(request.responseText))\n  }\n  request.send(JSON.stringify(data))\n}  Now we're ready to use it inside of our  submitHandler . We can call it with the 'POST' method and pass it the form data.  var apiURL = '//sandiegojs-vanilla-workshop.herokuapp.com'\n\nvar submitHandler = function(evt) {\n  evt.preventDefault()\n  var path = apiURL + '/forms'\n  xhr('POST', path, serializeArray('form'), function(err, data) {\n    if (err) { throw err }\n    console.log(data)\n  })\n}", 
            "title": "Build XHR and submit"
        }, 
        {
            "location": "/ajax/#handle-server-response", 
            "text": "Congratulations! We can now submit the form to the server and get a response. Now let's do something with the response.  We're going to write any errors from our XHR request to the screen. We're also going to render the contents of the form to the screen if it was successfully submitted.  Some of the methods we'll be using are:   Document.createElement  this method creates a DOM element of the type specified in the first parameter. For example, we can pass in  div ,  p ,  ul , etc.  Document.createTextNode  this method creates a text node that can be placed in the document. We'll use this to hold content we author.  Node.appendChild  this method can be called on any element created using createElement. As you can guess from the name it adds the node passed in to the end of node you call appendChild on.   Let's create a small helper function. It creates a DOM node and adds some text to it. We're going to be making a lot calls to this.  var createElementWithTextNode = function(tagName, tagContent) {}  Right inside of that function declaration we should add a call to  document.createElement .  var createElementWithTextNode = function(tagName, tagContent) {\n  var node = document.createElement(tagName)\n}  Next up we will create a text node that will hold whatever is inside of the tagContent variable.  var createElementWithTextNode = function(tagName, tagContent) {\n  var node = document.createElement(tagName)\n  var textNode = document.createTextNode(tagContent)\n}  Then we combine the two freshly created nodes. You can add other HTML nodes or text nodes to a node even if the HTML node would usually have children, such as  br .  var createElementWithTextNode = function(tagName, tagContent) {\n  var node = document.createElement(tagName)\n  var textNode = document.createTextNode(tagContent)\n  node.appendChild(textNode)\n}  There is a possibility that when we call this function we won't have any textContent, and calling  document.createTextNode  without textContent will cause an error. To avoid this kind of error wrap the creation and insertion of the textNode in a conditional test for textContent.  var createElementWithTextNode = function(tagName, tagContent) {\n  var node = document.createElement(tagName)\n  if (tagContent) {\n    var textNode = document.createTextNode(tagContent)\n    node.appendChild(textNode)\n  }\n}  And lastly we will return the node we created with a child text node.  var createElementWithTextNode = function(tagName, tagContent) {\n  var node = document.createElement(tagName)\n  if (tagContent) {\n    var textNode = document.createTextNode(tagContent)\n    node.appendChild(textNode)\n  }\n  return node\n}  Now that we have that built, we can start to output some content. First create the renderError function  var renderError = function(error) {}  The error render will be very simple. We are going to get a reference to the response container, create a node with our helper function, add a custom class to it, and append it to the document.  var renderError = function(error) {\n  var responseNode = document.querySelector('.response-wrapper')\n  var errorNode = createElementWithTextNode('div', error.toString())\n  errorNode.className = 'error'\n  responseNode.appendChild(errorNode)\n}  Now it's time to create the renderFormData function. This function is going to create many DOM nodes and append them to the response container.  var renderFormData = function(data) {}  The first thing we want to do inside of the renderFormData function is get a reference to the response container just like in our  renderError  function.  var renderFormData = function(data) {\n  var responseNode = document.querySelector('.response-wrapper')\n}  Now, let's create a generic success message so we can see on screen when the form was submitted and the backend saved it.  var renderFormData = function(data) {\n  var responseNode = document.querySelector('.response-wrapper')\n\n  //generic success message\n  var successNode = createElementWithTextNode('div', 'You\\'ve add a new card')\n  successNode.className = 'success'\n  responseNode.appendChild(successNode)\n}  Great, now we can give some kind of feedback to the user when the form is successfully processed by backend or not. Let's improve upon this, though. Let's show the information we entered when we submitted so we can verify it saved properly.  To do this we'll create a dictionary list, and fill it with all the some of the information that is returned by the request.  Let's use the  document.createElement  method to create a DL node that will hold all those terms and definitions. Append this to the  renderFormData  function.  var dictionaryNode = document.createElement('dl')  The next step is to add some terms and definitions. Let's use the  createElementWithTextNode  helper function to streamline the process of printing out the name. Add the next couple of lines after the  dictionaryNode  variable declaration and assignment.  //create a dom node with the name of a value\nvar termNode = createElementWithTextNode('dt', 'name')\ndictionaryNode.appendChild(termNode)\n\n//create another dom node with the value\nvar definitionNode = createElementWithTextNode('dd', data.name)\ndictionaryNode.appendChild(definitionNode)  Now, after the success message we're printing out the name we entered on the form. This response would be more useful if we showed more information. It would be good to show the name, email, and some other attributes. The simplest way to do this is to just copy and paste the code we just wrote and swap out name for email, github, etc.  But, there's a better way. If we create a list of keys we'd like to show on screen, we can loop through them with the native  forEach  method of an array. This method will iterate over an array and call a passed in callback function for each item in the array. The first parameter of the callback will be the current item that forEach is iterating through.  Create an array called keys. Place it just after the insertion of the success message, but keep it before the last set of statements we wrote.  var keys = ['name', 'email', 'github', 'twitter', 'city', 'state', 'bio']  Next call the  forEach  method on it and pass in an  anonymous function  with a single parameter of  key .  keys.forEach(function(key) {})  Move the name definition and insertion we wrote earlier into the callback. Change the text passed into  createElementWithTextNode . For the first call replace the string literal,  'name'  with the variable  key , and for the second call replace  data.name  with  data[key] . This will allow each iteration to print the current key, such as name or email, as the dictionary term and the actual value, such as \"John Doe\", will be the dictionary definition.  keys.forEach(function(key) {\n  //create a dom node with the name of a value\n  var termNode = createElementWithTextNode('dt', key)\n  dictionaryNode.appendChild(termNode)\n\n  //create another dom node with the value\n  var definitionNode = createElementWithTextNode('dd', data[key])\n  dictionaryNode.appendChild(definitionNode)\n})  If you review the array of keys we're looping through, you'll notice we didn't include  skills  like we did when we posted the data. That's because the content of that property is more complex than the simple strings of the other properties. If we want to print them out we'll have to write some custom logic.  Create a new dictionary term node like we do in the  forEach  callback, but set the text content to \"skills\".  var skillsTermNode = createElementWithTextNode('dt', 'skills')\ndictionaryNode.appendChild(skillsTermNode)  Let's add the dictionary definition, now. We'll add the actual skills information in the next step. We'll show all the skills as a list, so let's also add a  UL  node as well and store a reference to it in a variable so we can add  LI  elements to it later.  var skillsDefinitionNode = document.createElement('dd')\nvar skillsList = document.createElement('ul')\nskillsDefinitionNode.appendChild(skillsList)\ndictionaryNode.appendChild(skillsDefinitionNode)  Now that that's out of the way, let's loop through each skill we received, if any, and combine them into one dictionary definition. To accomplish this we'll test to see if there is any value stored in  skills_attributes . If there is then we can loop through all the skills by using the  forEach  method to loop through each complex element in the array and append a simpler set of information to the dictionary. In our case, we'll append only the description of each skill wrapped in a  LI  tag.  if (data.skills_attributes) {\n  data.skills_attributes_.forEach(function (skill) {\n    var skillNode = createElementWithTextNode('li', skill.description)\n    skillsList.appendChild(skillNode)\n  })\n}  The last steps are to add a custom class of  response  and append the dictionaryNode we've been populating to the responseNode from the beginning of the function. Here is the entire  renderFormData  function:  var renderFormData = function(data) {\n  var responseNode = document.querySelector('.response-wrapper')\n\n  //generic success message\n  var successNode = createElementWithTextNode('div', 'You\\'ve add a new card')\n  successNode.className = 'success'\n  responseNode.appendChild(successNode)\n\n  var dictionaryNode = document.createElement('dl')\n  var keys = ['name', 'email', 'github', 'twitter', 'city', 'state', 'bio']\n  keys.forEach(function(key) {\n    //create a dom node with the name of a value\n    var termNode = createElementWithTextNode('dt', key)\n    dictionaryNode.appendChild(termNode)\n\n    //create another dom node with the value\n    var definitionNode = createElementWithTextNode('dd', data[key])\n    dictionaryNode.appendChild(definitionNode)\n  })\n\n  var skillsTermNode = createElementWithTextNode('dt', 'skills')\n  dictionaryNode.appendChild(skillsTermNode)\n\n  var skillsDefinitionNode = document.createElement('dd')\n  var skillsList = document.createElement('ul')\n  skillsDefinitionNode.appendChild(skillsList)\n  dictionaryNode.appendChild(skillsDefinitionNode)\n\n  if (data.skills_attributes) {\n    data.skills_attributes.forEach(function (skill) {\n      var skillNode = createElementWithTextNode('li', skill.description)\n      skillsList.appendChild(skillNode)\n    })\n  }\n\n  dictionaryNode.className = 'response'\n  responseNode.appendChild(dictionaryNode)\n}  We've finished creating all the functions we need to process the response from our backend. Let's add  renderError     renderFormData  in the appropriate places in the original submitHandler. In addition, let's reset the form after we know it worked.  var submitHandler = function(evt) {\n  evt.preventDefault()\n  var path = apiURL + '/forms'\n  xhr('POST', path, serializeArray('form'), function(err, data) {\n    if (err) {\n      renderError(err)\n      throw err\n    }\n    console.log(data)\n    renderFormData(data)\n    document.querySelector('form').reset()\n  })\n}  If you fill out the form, you should see a response similar to what was described in the  Serialize the form data  section in your console. For example:  {\n   id : 1,\n   name :  Testy McTesterson ,\n   email :  test@sandiegojs.org ,\n   city :  San Diego ,\n   state :  CA ,\n   github :  testdev ,\n   twitter :  testtwitter ,\n   bio :  Lorem Ipsum... ,\n   skills_attributes : [\n    {\n       id : 1,\n       description :  cooking ,\n       form_id : 1,\n       created_at :  2016-01-21T07:09:01.640Z ,\n       updated_at :  2016-01-21T07:09:01.640Z \n    },\n    {\n       id : 2,\n       description :  cleaning ,\n       form_id : 1,\n       created_at :  2016-01-21T07:09:01.640Z ,\n       updated_at :  2016-01-21T07:09:01.640Z \n    }\n  ],\n   created_at :  2016-01-21T07:09:01.640Z ,\n   updated_at :  2016-01-21T07:09:01.640Z \n}  On screen you should see the this:   Congratulations! Now we have a fully submitting form that we can use to save people's information.", 
            "title": "Handle server response"
        }, 
        {
            "location": "/polish/", 
            "text": "Add JS Validation\n\n\nEarlier you added form validation using attributes. This is a quick and easy way to perform validation, but it does have limits. For example, you can't add custom error messages or styling. To get more flexibility and control, use JavaScript.\n\n\nIn this section, you will be playing with the HTML5 constraint validation API to check and customize the state of a form element. You have several goals:\n\n\n\n\nProvide a custom validation message when the email the user types is invalid\n\n\nHide that custom validation message as soon as the email is valid\n\n\nAdd custom validation logic to the State field without using an attribute\n\n\nApply custom styling to the validation error messages\n\n\nPrevent form submission if there are validation errors.\n\n\n\n\nTo achieve these goals you will:\n\n\n\n\nAdd a keyup event listener to the email field to present a custom message\n\n\nAdd \nvalidateForm\n function to handle validation logic\n\n\nModify the form submit event listener to validate the form\n\n\nLoop through the form elements and check their validity\n\n\nSet or clear the validation error messages\n\n\nAdd custom validation logic to the state field\n\n\n\n\nValidate email field\n\n\nFirst let's add a \nkeyup\n listener to check the validity of the email field as the user types. In order to do this we will need a reference to the email field.\n\n\nvar email = document.querySelector('[name=\nemail\n]')\n\n\n\n\nInside of our \nkeyup\n listener method, we will want to check the validity of the email. We can do this by getting a reference to the \ncurrentTarget\n on the passed in \nevent\n object. This is going to be our \nemail\n input.\n\n\nvar email = document.querySelector('[name=\nemail\n]')\n\nvar emailListener = function(evt) {\n  var input = evt.currentTarget\n}\nemail.addEventListener('keyup', emailListener)\n\n\n\n\nWe can then check the input's \nvalidity.typeMismatch\n property in order to determine if the email the user has typed is valid or not.\n\n\nIf there is a problem with the email validity, \ntypeMatch\n will be \ntrue\n. This is our opportunity to set a custom error message using the \nsetCustomValidity\n function.\n\n\nIf we pass \n''\n to \nsetCustomValidity\n the field will be considered valid. There are different types of \nvalidityStates\n.\n\n\nvar email = document.querySelector('[name=\nemail\n]')\n\nvar emailListener = function(evt) {\n  var input = evt.currentTarget\n  if (input.validity.typeMismatch) {\n    input.setCustomValidity('Oops, try a real email address.')\n  } else {\n    input.setCustomValidity('')\n  }\n}\nemail.addEventListener('keyup', emailListener)\n\n\n\n\nLet's try out the new logic. When we visit our form, add our name, type in an invalid email address, and hit submit, we now are able to see our custom error message.\n\n\nValidate form\n\n\nWe can use the technique above to handle each validated field, but we are still stuck with the standard formatting for the messages. To get more control, we will need to turn off the automatic validation and handle the submission event ourselves.\n\n\nIn order to do this, we need to disable the automatica validation behavior on our form.\n\n\nform.noValidate = true\n\n\n\n\nProTip\u2122: The same thing can be achieved byadding a \nnovalidate\n attribute to the form element.\n\n\nWe can confirm that validation is off now by entering garbage data in the form and submitting.\n\n\nWith the automatic validation turned off, we now have more control over when the validation check is done.\n\n\nLet's create a new function, \nvalidateForm\n, to handle the validation check. This function, after we implement it fully, will determine any field errors and allow the form to determine if it valid.\n\n\nvar validateForm = function(form) { }\n\n\n\n\nUpdate submit handler\n\n\nBack in the \"Add submit event\" section we added a \nsubmit\n event handler. We need to modify that to call the \nvalidateForm\n method.\n\n\nvar submitHandler = function(evt) {\n  evt.preventDefault()\n\n  var form = evt.target\n  validateForm(form)\n\n  // ...\n}\n\n\n\n\nNow we need to have the form check if it is valid before submitting data to the server. The \nform\n element has a convenient \ncheckValidity\n function to do just that.\n\n\n\nvar submitHandler = function(evt) {\n  evt.preventDefault()\n\n  var form = evt.target\n  validateForm(form)\n\n  // if no error, go ahead and submit\n  if (form.checkValidity()) {\n    // ...\n  }\n}\n\n\n\n\nLoop through the fields\n\n\nEvery form has an elements array and we can use this to loop through the fields.\n\n\nvar validateForm = function(form) {\n  for (var f = 0; f \n form.elements.length; f++) {\n\n  }\n}\n\n\n\n\nWithin the loop, get a reference to the current field.\n\n\nvar validateForm = function(form) {\n  for (var f = 0; f \n form.elements.length; f++) {\n    var field = form.elements[f]\n  }\n}\n\n\n\n\nThe behavior of the form hasn't changed so charge on to the next section.\n\n\nCheck the field validity\n\n\nWe are going to start off using the native validation check for a field for our validations, first.\n\n\nLet's create a new function called \nisValid\n that recieves a field as a parameter.\n\n\nLike the form, fields have a \ncheckValidity\n method. Use this method to determine the return value for the function.\n\n\nvar isValid = function(field) {\n  return field.checkValidity()\n}\n\n\n\n\nNow we can call this method for each of the fields we pass over in our loop.\n\n\nvar validateForm = function(form) {\n  for (var f = 0; f \n form.elements.length; f++) {\n    var field = form.elements[f]\n    if(isValid(field)) {\n      // remove error styles and messages\n    } else {\n      // style field, show error, etc.\n    }\n  }\n}\n\n\n\n\nSet and clear error messages\n\n\nUnder each of the the input's in the \napp/index.html\n we are going to want to add a \nspan\n/span\n element so that we have somewhere to output an error message. Let's give it a custom class of \nerror-message\n so that we cans style it later.\n\n\nspan class='error-message'\n/span\n\n\n\n\n\nLet's make a function that sets the error message for a given field.\n\n\nvar setError = function(field) { }\n\n\n\n\nIn order to get a reference to the \nspan\n immediately after the field we want to display the error for, we will use the \nnextElementSibling\n method.\n\n\nOnce we have our \nspan\n reference, all we need to do is set the \ninnerHTML\n to be the field's \nvalidationMessage\n. The \nvalidationMessage\n is either the default message from the browser or a custom message that we set.\n\n\nvar setError = function(field) {\n  var error = field.nextElementSibling\n  if (error) {\n    error.innerHTML = field.validationMessage\n  }\n}\n\n\n\n\nLet's also setup a similar function to clear our error message when the field becomes valid again.\n\n\nvar clearError = function(field) {\n  var error = field.nextElementSibling\n  if (error) {\n    error.innerHTML = ''\n  }\n}\n\n\n\n\nProTip\u2122: This is just one way of handling error messages. For example, you could use CSS to show and hide error messages or put all validation errors in a central location on the page.\n\n\nNow that we have created our \nsetError\n and \nclearError\n methods, we can call them from our \nvalidateForm\n method.\n\n\nvar validateForm = function(form) {\n  for (var f = 0; f \n form.elements.length; f++) {\n    var field = form.elements[f]\n    if(isValid(field)) {\n      clearError(field)\n    } else {\n      setError(field)\n    }\n  }\n}\n\n\n\n\nWhen we go to the browser and try it out, we will now see our custom error message from the email input. But as we type in the email field and put in a valid email, the message does not disappear.\n\n\nLet's add the \nclearError\n to our email keyup handler.\n\n\nvar email = document.querySelector('[name=\nemail\n]')\n\nvar emailListener = function(evt) {\n  var input = evt.currentTarget\n  if (input.validity.typeMismatch) {\n    input.setCustomValidity('Oops, try a real email address.')\n  } else {\n    input.setCustomValidity('')\n    clearError(input)\n  }\n}\nemail.addEventListener('keyup', emailListener)\n\n\n\n\nCustom validation logic\n\n\nTime for the bonus round! Custom validation logic could involve evaluating multiple fields on the form, making a call to the server, or performing some calculation in a worker thread. While those are beyond the time you have for this workshop, this section will walk you through creating some custom logic.\n\n\nAs an example, let's add a custom 'State' validation check. We will add this logic to the top of the \nisValid\n function from earlier.\n\n\nFirst, we wnat to check if the field tha is passed in is in fact the \nstate\n field, so verify the \nname\n matches \nstate\n.\n\n\nFor this example, let's say that only \"CA\", \"TX\", and \"NY\" are valid states.\n\n\n var sValid = function(field) {\n  if (field.name === 'state') {\n    var validStates = ['CA', 'TX', 'NY']\n    if (validStates.indexOf(field.value) === -1) {\n      // invalid state\n    } else {\n      // valid state\n    }\n  }\n  return field.checkValidity()\n}\n\n\n\n\nWhen the state is invalid we want to set a custom validity message. When it is valid, we can set an empty string like before.\n\n\nvar sValid = function(field) {\n  if (validStates.indexOf(field.value) === -1) {\n    field.setCustomValidity('Please provide a valid state (CA, TX, or NY)')\n  } else {\n    field.setCustomValidity('')\n  }\n  return field.checkValidity()\n}\n\n\n\n\nNow when we try to submit without a state or with an invalid state we should see our custom error message like before.\n\n\nWelcome text with cookies\n\n\nCookies are a classic way to provide a unique visitor experience based on previous visits.  In our case we would like to show a generic welcome message the first time a user visits our site, but show an alternative, and more personalized message when a user returns for any additional visits from the same device.  Note that cookies are stored on the user\u2019s device, so if they return from a new device or clear their cookies, we won\u2019t have a cookie and will not know they are a returning visitor.  Cookies are often associated with tracking of user visits, be sure to read up on that before implementing on your own.\n\n\nHere are the basics.   Cookies are stored as key value pairs as a strings.  The DOM API allows you to set cookies by assigning a value to document.cookie.  It must have a name, should have a value, and may have an expiration date for example:\n\n\ndocument.cookie = 'returning=true; expires=Mon, 1 Feb 2016 12:00:UTC;'\n\n\n\n\nThis would set a cookie with the key = 'returning' and value = 'true', as well as an expiration date.  This is when the cookie will go bye bye.\n\n\nGetting a cookie involves more work because you have to parse the value of document.cookie (which remember is just a plain text string with ; separators).  It could include quite a few key value pairs, so most users will roll their own GET and SET methods to deal with parsing cookies.\n\n\nLet\u2019s add cookie set and get methods to help us handle our visitor\u2019s session.\n\n\nfunction setCookie(cookieName, cookieValue, cookieDays) {\n  var expireTime = new Date()\n  expireTime.setTime(expireTime.getTime() + cookieDays * 24 * 60 * 60)\n  var expires = \nexpires=\n + expireTime.toUTCString()\n  document.cookie = cookieName + \n=\n + cookieValue + \n; \n + expires\n}\n\nfunction getCookie(cookieName) {\n  var name = cookieName + \n=\n\n  var cookieArray = document.cookie.split(';')\n  for(var i=0; i \n cookieArray.length; i++) {\n    var cookieStr = cookieArray[i]\n    while (cookieStr.charAt(0)==' ') {\n      cookieStr = cookieStr.substring(1)\n    }\n    if (cookieStr.indexOf(name) == 0) {\n      return cookieStr.substring(name.length,cookieStr.length)\n    }\n  }\n  return \n;\n}\n\n\n\n\nThen we will add a conditional block of code that will update the welcome message when a user returns, or set a cookie if its the first visit (or if the cookies have been cleared or expired).\n\n\nif(getCookie('returning') === 'yes') {\n  document.querySelector('.greeting').innerHTML = \nWelcome back to the program.\n\n} else {\n  setCookie('returning', 'yes', 2)\n}\n\n\n\n\nThen try refreshing the page and watch it add a custom greeting.  You can clear out your cookies using the Chrome Dev tools \n Resources \n Cookies\n\n\nAs a bonus try refactoring this code to cookie and display the users name in the greeting message when they return.\n\n\nA couple of other fun facts about cookies: You can store objects in cookies, but you will need to be sure to serialize them and they must be strings when assigned to document.cookie.  Cookie security is handled for you:  Cookies are stored with a security feature tied to the domain that was used to store the cookie.  That means that your code running in the browser can only read the cookies that were set on the same domain.  Also note, cookies are stored as strings in plain text, so any savvy user can look at the cookies on their machine (delete, or modify them) as they see fit.", 
            "title": "Polish"
        }, 
        {
            "location": "/polish/#add-js-validation", 
            "text": "Earlier you added form validation using attributes. This is a quick and easy way to perform validation, but it does have limits. For example, you can't add custom error messages or styling. To get more flexibility and control, use JavaScript.  In this section, you will be playing with the HTML5 constraint validation API to check and customize the state of a form element. You have several goals:   Provide a custom validation message when the email the user types is invalid  Hide that custom validation message as soon as the email is valid  Add custom validation logic to the State field without using an attribute  Apply custom styling to the validation error messages  Prevent form submission if there are validation errors.   To achieve these goals you will:   Add a keyup event listener to the email field to present a custom message  Add  validateForm  function to handle validation logic  Modify the form submit event listener to validate the form  Loop through the form elements and check their validity  Set or clear the validation error messages  Add custom validation logic to the state field", 
            "title": "Add JS Validation"
        }, 
        {
            "location": "/polish/#validate-email-field", 
            "text": "First let's add a  keyup  listener to check the validity of the email field as the user types. In order to do this we will need a reference to the email field.  var email = document.querySelector('[name= email ]')  Inside of our  keyup  listener method, we will want to check the validity of the email. We can do this by getting a reference to the  currentTarget  on the passed in  event  object. This is going to be our  email  input.  var email = document.querySelector('[name= email ]')\n\nvar emailListener = function(evt) {\n  var input = evt.currentTarget\n}\nemail.addEventListener('keyup', emailListener)  We can then check the input's  validity.typeMismatch  property in order to determine if the email the user has typed is valid or not.  If there is a problem with the email validity,  typeMatch  will be  true . This is our opportunity to set a custom error message using the  setCustomValidity  function.  If we pass  ''  to  setCustomValidity  the field will be considered valid. There are different types of  validityStates .  var email = document.querySelector('[name= email ]')\n\nvar emailListener = function(evt) {\n  var input = evt.currentTarget\n  if (input.validity.typeMismatch) {\n    input.setCustomValidity('Oops, try a real email address.')\n  } else {\n    input.setCustomValidity('')\n  }\n}\nemail.addEventListener('keyup', emailListener)  Let's try out the new logic. When we visit our form, add our name, type in an invalid email address, and hit submit, we now are able to see our custom error message.", 
            "title": "Validate email field"
        }, 
        {
            "location": "/polish/#validate-form", 
            "text": "We can use the technique above to handle each validated field, but we are still stuck with the standard formatting for the messages. To get more control, we will need to turn off the automatic validation and handle the submission event ourselves.  In order to do this, we need to disable the automatica validation behavior on our form.  form.noValidate = true  ProTip\u2122: The same thing can be achieved byadding a  novalidate  attribute to the form element.  We can confirm that validation is off now by entering garbage data in the form and submitting.  With the automatic validation turned off, we now have more control over when the validation check is done.  Let's create a new function,  validateForm , to handle the validation check. This function, after we implement it fully, will determine any field errors and allow the form to determine if it valid.  var validateForm = function(form) { }", 
            "title": "Validate form"
        }, 
        {
            "location": "/polish/#update-submit-handler", 
            "text": "Back in the \"Add submit event\" section we added a  submit  event handler. We need to modify that to call the  validateForm  method.  var submitHandler = function(evt) {\n  evt.preventDefault()\n\n  var form = evt.target\n  validateForm(form)\n\n  // ...\n}  Now we need to have the form check if it is valid before submitting data to the server. The  form  element has a convenient  checkValidity  function to do just that.  \nvar submitHandler = function(evt) {\n  evt.preventDefault()\n\n  var form = evt.target\n  validateForm(form)\n\n  // if no error, go ahead and submit\n  if (form.checkValidity()) {\n    // ...\n  }\n}", 
            "title": "Update submit handler"
        }, 
        {
            "location": "/polish/#loop-through-the-fields", 
            "text": "Every form has an elements array and we can use this to loop through the fields.  var validateForm = function(form) {\n  for (var f = 0; f   form.elements.length; f++) {\n\n  }\n}  Within the loop, get a reference to the current field.  var validateForm = function(form) {\n  for (var f = 0; f   form.elements.length; f++) {\n    var field = form.elements[f]\n  }\n}  The behavior of the form hasn't changed so charge on to the next section.", 
            "title": "Loop through the fields"
        }, 
        {
            "location": "/polish/#check-the-field-validity", 
            "text": "We are going to start off using the native validation check for a field for our validations, first.  Let's create a new function called  isValid  that recieves a field as a parameter.  Like the form, fields have a  checkValidity  method. Use this method to determine the return value for the function.  var isValid = function(field) {\n  return field.checkValidity()\n}  Now we can call this method for each of the fields we pass over in our loop.  var validateForm = function(form) {\n  for (var f = 0; f   form.elements.length; f++) {\n    var field = form.elements[f]\n    if(isValid(field)) {\n      // remove error styles and messages\n    } else {\n      // style field, show error, etc.\n    }\n  }\n}", 
            "title": "Check the field validity"
        }, 
        {
            "location": "/polish/#set-and-clear-error-messages", 
            "text": "Under each of the the input's in the  app/index.html  we are going to want to add a  span /span  element so that we have somewhere to output an error message. Let's give it a custom class of  error-message  so that we cans style it later.  span class='error-message' /span   Let's make a function that sets the error message for a given field.  var setError = function(field) { }  In order to get a reference to the  span  immediately after the field we want to display the error for, we will use the  nextElementSibling  method.  Once we have our  span  reference, all we need to do is set the  innerHTML  to be the field's  validationMessage . The  validationMessage  is either the default message from the browser or a custom message that we set.  var setError = function(field) {\n  var error = field.nextElementSibling\n  if (error) {\n    error.innerHTML = field.validationMessage\n  }\n}  Let's also setup a similar function to clear our error message when the field becomes valid again.  var clearError = function(field) {\n  var error = field.nextElementSibling\n  if (error) {\n    error.innerHTML = ''\n  }\n}  ProTip\u2122: This is just one way of handling error messages. For example, you could use CSS to show and hide error messages or put all validation errors in a central location on the page.  Now that we have created our  setError  and  clearError  methods, we can call them from our  validateForm  method.  var validateForm = function(form) {\n  for (var f = 0; f   form.elements.length; f++) {\n    var field = form.elements[f]\n    if(isValid(field)) {\n      clearError(field)\n    } else {\n      setError(field)\n    }\n  }\n}  When we go to the browser and try it out, we will now see our custom error message from the email input. But as we type in the email field and put in a valid email, the message does not disappear.  Let's add the  clearError  to our email keyup handler.  var email = document.querySelector('[name= email ]')\n\nvar emailListener = function(evt) {\n  var input = evt.currentTarget\n  if (input.validity.typeMismatch) {\n    input.setCustomValidity('Oops, try a real email address.')\n  } else {\n    input.setCustomValidity('')\n    clearError(input)\n  }\n}\nemail.addEventListener('keyup', emailListener)", 
            "title": "Set and clear error messages"
        }, 
        {
            "location": "/polish/#custom-validation-logic", 
            "text": "Time for the bonus round! Custom validation logic could involve evaluating multiple fields on the form, making a call to the server, or performing some calculation in a worker thread. While those are beyond the time you have for this workshop, this section will walk you through creating some custom logic.  As an example, let's add a custom 'State' validation check. We will add this logic to the top of the  isValid  function from earlier.  First, we wnat to check if the field tha is passed in is in fact the  state  field, so verify the  name  matches  state .  For this example, let's say that only \"CA\", \"TX\", and \"NY\" are valid states.   var sValid = function(field) {\n  if (field.name === 'state') {\n    var validStates = ['CA', 'TX', 'NY']\n    if (validStates.indexOf(field.value) === -1) {\n      // invalid state\n    } else {\n      // valid state\n    }\n  }\n  return field.checkValidity()\n}  When the state is invalid we want to set a custom validity message. When it is valid, we can set an empty string like before.  var sValid = function(field) {\n  if (validStates.indexOf(field.value) === -1) {\n    field.setCustomValidity('Please provide a valid state (CA, TX, or NY)')\n  } else {\n    field.setCustomValidity('')\n  }\n  return field.checkValidity()\n}  Now when we try to submit without a state or with an invalid state we should see our custom error message like before.", 
            "title": "Custom validation logic"
        }, 
        {
            "location": "/polish/#welcome-text-with-cookies", 
            "text": "Cookies are a classic way to provide a unique visitor experience based on previous visits.  In our case we would like to show a generic welcome message the first time a user visits our site, but show an alternative, and more personalized message when a user returns for any additional visits from the same device.  Note that cookies are stored on the user\u2019s device, so if they return from a new device or clear their cookies, we won\u2019t have a cookie and will not know they are a returning visitor.  Cookies are often associated with tracking of user visits, be sure to read up on that before implementing on your own.  Here are the basics.   Cookies are stored as key value pairs as a strings.  The DOM API allows you to set cookies by assigning a value to document.cookie.  It must have a name, should have a value, and may have an expiration date for example:  document.cookie = 'returning=true; expires=Mon, 1 Feb 2016 12:00:UTC;'  This would set a cookie with the key = 'returning' and value = 'true', as well as an expiration date.  This is when the cookie will go bye bye.  Getting a cookie involves more work because you have to parse the value of document.cookie (which remember is just a plain text string with ; separators).  It could include quite a few key value pairs, so most users will roll their own GET and SET methods to deal with parsing cookies.  Let\u2019s add cookie set and get methods to help us handle our visitor\u2019s session.  function setCookie(cookieName, cookieValue, cookieDays) {\n  var expireTime = new Date()\n  expireTime.setTime(expireTime.getTime() + cookieDays * 24 * 60 * 60)\n  var expires =  expires=  + expireTime.toUTCString()\n  document.cookie = cookieName +  =  + cookieValue +  ;   + expires\n}\n\nfunction getCookie(cookieName) {\n  var name = cookieName +  = \n  var cookieArray = document.cookie.split(';')\n  for(var i=0; i   cookieArray.length; i++) {\n    var cookieStr = cookieArray[i]\n    while (cookieStr.charAt(0)==' ') {\n      cookieStr = cookieStr.substring(1)\n    }\n    if (cookieStr.indexOf(name) == 0) {\n      return cookieStr.substring(name.length,cookieStr.length)\n    }\n  }\n  return  ;\n}  Then we will add a conditional block of code that will update the welcome message when a user returns, or set a cookie if its the first visit (or if the cookies have been cleared or expired).  if(getCookie('returning') === 'yes') {\n  document.querySelector('.greeting').innerHTML =  Welcome back to the program. \n} else {\n  setCookie('returning', 'yes', 2)\n}  Then try refreshing the page and watch it add a custom greeting.  You can clear out your cookies using the Chrome Dev tools   Resources   Cookies  As a bonus try refactoring this code to cookie and display the users name in the greeting message when they return.  A couple of other fun facts about cookies: You can store objects in cookies, but you will need to be sure to serialize them and they must be strings when assigned to document.cookie.  Cookie security is handled for you:  Cookies are stored with a security feature tied to the domain that was used to store the cookie.  That means that your code running in the browser can only read the cookies that were set on the same domain.  Also note, cookies are stored as strings in plain text, so any savvy user can look at the cookies on their machine (delete, or modify them) as they see fit.", 
            "title": "Welcome text with cookies"
        }, 
        {
            "location": "/bonus/", 
            "text": "Bonus Section!\n\n\nSo you've finished the workshop before everyone else, or you're looking for some more challenging peices to work on? You've come to the right section!\n\n\nThe following are some sections that will provide the beginnings to some self-guided learning experiences that build on the skills we've learned in this workshop.\n\n\nAdding classes for error messages\n\n\nWhen we added our JavaScript validation to the form, we just provided a simple span after the input to encapsulate our messages. This is great for getting something working, but we can do all sorts of pretty things with it to make it more user friendly.\n\n\nTry changing the input box styles so that they get a glowing red or green border around them when they are valid or invalid. There are some great CSS tutorials on \nCSS-Tricks\n, and there just happens to be one on \nglowing blue inputs\n.\n\n\nTest with Mocha\n\n\nTesting your code is important for many reasons.  Perhaps the most important reason is that testing gives you a high degree of confidence that the code you write does what you think it does.  It is also a great way to ensure that you can refactor your code, squash bugs, or expand your app's functionality without lots of manual regression testing.\n\n\nThere are many testing frameworks you could use to write unit tests. We selected Mocha and wired it up for you. It's a very modern, feature rich, and popular testing framework (that also works well on the server side).  You can load \ntest/test.html\n in your browser and view the status of the sample suite.\n\n\nNext, head over to these links and learn about the assertion libraries, and testing  we have included:\n\n\nChai\n - The chain-capable BDD styles provide an expressive language and readable style, while the TDD assert style provides a more classical feel\n\n\nSinon\n - Standalone test spies, stubs and mocks for JavaScript.\n\n\nSinon-Chai\n - Assertions for the Sinon.JS mocking framework\n\n\nThen try your hand at writing some tests in \ntest/index.spec.js\n to exercise your code and ensure it is doing what you \nexpect\n, \nassert\n, or think it \nshould\n be doing.\n\n\nHeroku to Publish\n\n\nHeroku\n is a web hosting platform that allows developers to go from code to running apps in minutes. It has a free tier, as well as a super fast workflow. To try it out create a free account on Heroku, and then use the button below to automatically deploy this app directly from GitHub to a running Heroku instance.\n\n\n\n\nRead [Getting Started with Node.js on Heroku][node-heroku] for more information.\n\n\nES2015\n\n\nYou'll probably remember that the boilerplate for this workshop was setup with \nGulp\n. If you take a peak at the \ntasks/\n directory at the \nscripts\n task and see how the scripts are being built you will notice the use of \nBrowserify\n and the 'babelify' tranform which uses \nBabel\n.\n\n\nBabel allows us to use ES2015 in the browser. There are many different plugins and presets you can add to the project's Babel configuration in \n.babelrc\n. The default \nes2015\n preset should get you pretty far, but it would be useful to read up more information about Babel presets and plugins. Adding different plugins allows you to add more natively unsupported future features of EcmaScript.\n\n\nBrowserify allows us to use modules in our project. With the combination of Browserify and Bable we are able to have a great module ecosystem and ES2015.\n\n\nOne bonus skill of this workshop is moving the functionality of this app into composable modules. This will also allow us to add isolated unit testing to our test suite, rather than just integration tests.\n\n\nGive this a try on your own!\n\n\nFork the API and expand\n\n\nThe API for this project was build using \nRails-API\n[rail-api] and is publicly available for forking and PRs at \nsandiegojs/sandiegojs-vanilla-workshop\n. Rails-API is similar to rails, except that it is API only. It doesn't include the view layer and other pieces that are unnecessary for creating an API.\n\n\nIf you want to expand on this example, you can try generating additional models and controllers in the API and adding more routes to your client-side application.", 
            "title": "Bonus"
        }, 
        {
            "location": "/bonus/#bonus-section", 
            "text": "So you've finished the workshop before everyone else, or you're looking for some more challenging peices to work on? You've come to the right section!  The following are some sections that will provide the beginnings to some self-guided learning experiences that build on the skills we've learned in this workshop.", 
            "title": "Bonus Section!"
        }, 
        {
            "location": "/bonus/#adding-classes-for-error-messages", 
            "text": "When we added our JavaScript validation to the form, we just provided a simple span after the input to encapsulate our messages. This is great for getting something working, but we can do all sorts of pretty things with it to make it more user friendly.  Try changing the input box styles so that they get a glowing red or green border around them when they are valid or invalid. There are some great CSS tutorials on  CSS-Tricks , and there just happens to be one on  glowing blue inputs .", 
            "title": "Adding classes for error messages"
        }, 
        {
            "location": "/bonus/#test-with-mocha", 
            "text": "Testing your code is important for many reasons.  Perhaps the most important reason is that testing gives you a high degree of confidence that the code you write does what you think it does.  It is also a great way to ensure that you can refactor your code, squash bugs, or expand your app's functionality without lots of manual regression testing.  There are many testing frameworks you could use to write unit tests. We selected Mocha and wired it up for you. It's a very modern, feature rich, and popular testing framework (that also works well on the server side).  You can load  test/test.html  in your browser and view the status of the sample suite.  Next, head over to these links and learn about the assertion libraries, and testing  we have included:  Chai  - The chain-capable BDD styles provide an expressive language and readable style, while the TDD assert style provides a more classical feel  Sinon  - Standalone test spies, stubs and mocks for JavaScript.  Sinon-Chai  - Assertions for the Sinon.JS mocking framework  Then try your hand at writing some tests in  test/index.spec.js  to exercise your code and ensure it is doing what you  expect ,  assert , or think it  should  be doing.", 
            "title": "Test with Mocha"
        }, 
        {
            "location": "/bonus/#heroku-to-publish", 
            "text": "Heroku  is a web hosting platform that allows developers to go from code to running apps in minutes. It has a free tier, as well as a super fast workflow. To try it out create a free account on Heroku, and then use the button below to automatically deploy this app directly from GitHub to a running Heroku instance.   Read [Getting Started with Node.js on Heroku][node-heroku] for more information.", 
            "title": "Heroku to Publish"
        }, 
        {
            "location": "/bonus/#es2015", 
            "text": "You'll probably remember that the boilerplate for this workshop was setup with  Gulp . If you take a peak at the  tasks/  directory at the  scripts  task and see how the scripts are being built you will notice the use of  Browserify  and the 'babelify' tranform which uses  Babel .  Babel allows us to use ES2015 in the browser. There are many different plugins and presets you can add to the project's Babel configuration in  .babelrc . The default  es2015  preset should get you pretty far, but it would be useful to read up more information about Babel presets and plugins. Adding different plugins allows you to add more natively unsupported future features of EcmaScript.  Browserify allows us to use modules in our project. With the combination of Browserify and Bable we are able to have a great module ecosystem and ES2015.  One bonus skill of this workshop is moving the functionality of this app into composable modules. This will also allow us to add isolated unit testing to our test suite, rather than just integration tests.  Give this a try on your own!", 
            "title": "ES2015"
        }, 
        {
            "location": "/bonus/#fork-the-api-and-expand", 
            "text": "The API for this project was build using  Rails-API [rail-api] and is publicly available for forking and PRs at  sandiegojs/sandiegojs-vanilla-workshop . Rails-API is similar to rails, except that it is API only. It doesn't include the view layer and other pieces that are unnecessary for creating an API.  If you want to expand on this example, you can try generating additional models and controllers in the API and adding more routes to your client-side application.", 
            "title": "Fork the API and expand"
        }, 
        {
            "location": "/about/", 
            "text": "About this Workshop\n\n\nThis workshop was put together by the time and efforts of several people, with review from many more. It would not be possible with out the organizers of the SanDiego.js Community, their sponsors, or \nYOU!\n\n\nThe Instructors\n\n\nThank you to all the instructors who were able to come and offer their time and experience to the workshop. Many of you also took time to review our content and offer suggestions, which we very much appreciate. The attendees were able to receive a more personalized experience thanks to you.\n\n\nSponsors\n\n\nThis event was made possible by our gracious sponsors! Huge thanks to \nZeeto\n for providing our event space and \nLEARN\n for the food and the drinks.\n\n\n\n  \n\n  \n\n    \nZeeto\n develops technology that generates targetable, high value ad inventory.  Zeeto\u2019s proprietary algorithms determine the right questions to ask at the right time in order to show the most relevant advertisements possible, all while maximizing user experience. This high quality inventory is then available across the Zeeto Ad Exchange.\n  \n\n  \n\n\n\n\n\n\n  \n\n  \n\n    \nLEARN Academy\n is a collaborative and immersive four month full-time coding bootcamp that teaches adults the skills they need to start a career in web development. The final month of the course is an internship with a local San Diego company. Students enter the workforce with several portfolio pieces and real world experience on their resume.\n  \n\n  \n\n\n\n\n\nThe Team\n\n\n\n  \n\n  \n\n    \nHeather Brysiewicz\n is an Ember.js consultant and full-stack developer who transplanted from Chicago. Along with her pomeranian, Squirt, she enjoys life at the beach and long nights at coffee shops. She also organizes the \nSan Diego Ember Community\n.\n  \n\n  \n\n\n\n\n\n\n  \n\n  \n\n    \nTrey Hunner\n is an open source advocate and full-stack web developer.  He co-founded the \nEditorConfig\n project.  Trey also helps co-organize \nSD Hacker News\n and \nSD Python\n meetups.\n  \n\n  \n\n\n\n\n\n\n  \n\n  \n\n    \nTodd Bashor\n is a web development coach at \nThe Starter's Academy\n. He is a software industry veteran and loves teaching others about the power of web technology.\n  \n\n  \n\n\n\n\n\n\n  \n\n  \n\n    \nMichael Roberts Jr\n is a seasoned full-stack JavaScript developer, Sr. Software Engineer at \nZeeto\n and Founder of \nSan Diego Code School\n.\n  \n\n  \n\n\n\n\n\n\n  \n\n  \n\n    \nStuart Runyan\n is a San Diego native who's passionate about experiences the web can offer us and the technologies used to craft those. Currently working at \nZesty.io\n as a Software Engineer. Available for taco shop advisement.\n  \n\n  \n\n\n\n\n\n\n  \n\n  \n\n    \nAbishai Gray\n is full stack developer, but specializes in front end development and tooling. In addition to sharing his in-depth knowledge, he loves to hear about what other people are doing and how they feel about the development projects they're working on.\n  \n\n  \n\n\n\n\n\nComments and suggestions\n\n\nWe would love to hear what you thought about the content and event. If you have suggestions, changes, or have found errors in the content of this workshop, please submit an issue on github for the appropriate repository\n\n\n\n\nBoilerplate app for the workshop\n\n\nDocumentation for the workshop\n\n\n\n\nOr, if you would like something a bit more personal, please feel free to email any of the following:\n\n\n\n\nSanDiego.js Community \nsandiegojs@gmail.com\n:\n All organizers have access to this email\n\n\nHeather Brysiewicz \nh.a.brysiewicz@gmail.com\n:\n Organizer for SanDiego.js", 
            "title": "About"
        }, 
        {
            "location": "/about/#about-this-workshop", 
            "text": "This workshop was put together by the time and efforts of several people, with review from many more. It would not be possible with out the organizers of the SanDiego.js Community, their sponsors, or  YOU!", 
            "title": "About this Workshop"
        }, 
        {
            "location": "/about/#the-instructors", 
            "text": "Thank you to all the instructors who were able to come and offer their time and experience to the workshop. Many of you also took time to review our content and offer suggestions, which we very much appreciate. The attendees were able to receive a more personalized experience thanks to you.", 
            "title": "The Instructors"
        }, 
        {
            "location": "/about/#sponsors", 
            "text": "This event was made possible by our gracious sponsors! Huge thanks to  Zeeto  for providing our event space and  LEARN  for the food and the drinks.  \n   \n   \n     Zeeto  develops technology that generates targetable, high value ad inventory.  Zeeto\u2019s proprietary algorithms determine the right questions to ask at the right time in order to show the most relevant advertisements possible, all while maximizing user experience. This high quality inventory is then available across the Zeeto Ad Exchange.\n   \n     \n   \n   \n     LEARN Academy  is a collaborative and immersive four month full-time coding bootcamp that teaches adults the skills they need to start a career in web development. The final month of the course is an internship with a local San Diego company. Students enter the workforce with several portfolio pieces and real world experience on their resume.", 
            "title": "Sponsors"
        }, 
        {
            "location": "/about/#the-team", 
            "text": "Heather Brysiewicz  is an Ember.js consultant and full-stack developer who transplanted from Chicago. Along with her pomeranian, Squirt, she enjoys life at the beach and long nights at coffee shops. She also organizes the  San Diego Ember Community .\n   \n     \n   \n   \n     Trey Hunner  is an open source advocate and full-stack web developer.  He co-founded the  EditorConfig  project.  Trey also helps co-organize  SD Hacker News  and  SD Python  meetups.\n   \n     \n   \n   \n     Todd Bashor  is a web development coach at  The Starter's Academy . He is a software industry veteran and loves teaching others about the power of web technology.\n   \n     \n   \n   \n     Michael Roberts Jr  is a seasoned full-stack JavaScript developer, Sr. Software Engineer at  Zeeto  and Founder of  San Diego Code School .\n   \n     \n   \n   \n     Stuart Runyan  is a San Diego native who's passionate about experiences the web can offer us and the technologies used to craft those. Currently working at  Zesty.io  as a Software Engineer. Available for taco shop advisement.\n   \n     \n   \n   \n     Abishai Gray  is full stack developer, but specializes in front end development and tooling. In addition to sharing his in-depth knowledge, he loves to hear about what other people are doing and how they feel about the development projects they're working on.", 
            "title": "The Team"
        }, 
        {
            "location": "/about/#comments-and-suggestions", 
            "text": "We would love to hear what you thought about the content and event. If you have suggestions, changes, or have found errors in the content of this workshop, please submit an issue on github for the appropriate repository   Boilerplate app for the workshop  Documentation for the workshop   Or, if you would like something a bit more personal, please feel free to email any of the following:   SanDiego.js Community  sandiegojs@gmail.com :  All organizers have access to this email  Heather Brysiewicz  h.a.brysiewicz@gmail.com :  Organizer for SanDiego.js", 
            "title": "Comments and suggestions"
        }
    ]
}