<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  
  <title>Polish - Vanilla JavaScript in the Browser</title>
  

  <link rel="shortcut icon" href="../img/favicon.ico">

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="../css/highlight.css">

  
  <script>
    // Current page data
    var mkdocs_page_name = "Polish";
    var mkdocs_page_input_path = "polish.md";
    var mkdocs_page_url = "/polish/";
  </script>
  
  <script src="../js/jquery-2.1.1.min.js"></script>
  <script src="../js/modernizr-2.8.3.min.js"></script>
  <script type="text/javascript" src="../js/highlight.pack.js"></script>
  <script src="../js/theme.js"></script> 

  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> Vanilla JavaScript in the Browser</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        <ul class="current">
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="..">Home</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../dom/">The DOM</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../manipulate/">Manipulating the DOM</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../ajax/">AJAX Form Submission</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 current">
        <a class="current" href="./">Polish</a>
        
            <ul>
            
                <li class="toctree-l3"><a href="#add-js-validation">Add JS Validation</a></li>
                
                    <li><a class="toctree-l4" href="#validate-email-field">Validate email field</a></li>
                
                    <li><a class="toctree-l4" href="#validate-form">Validate form</a></li>
                
                    <li><a class="toctree-l4" href="#check-the-field-validity">Check the field validity</a></li>
                
            
                <li class="toctree-l3"><a href="#welcome-text-with-cookies">Welcome text with cookies</a></li>
                
            
            </ul>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../bonus/">Bonus</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../about/">About</a>
        
    </li>
<li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">Vanilla JavaScript in the Browser</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
    
    <li>Polish</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="add-js-validation">Add JS Validation</h1>
<p>Earlier you added form validation using attributes. This is a quick and easy way to perform validation, but it does have limits. For example, you can't add custom error messages or styling. To get more flexibility and control, use JavaScript.</p>
<p>In this section, you will be playing with the HTML5 constraint validation API to check and customize the state of a form element. You have several goals:</p>
<ul>
<li>Provide a custom validation message when the email the user types is invalid</li>
<li>Hide that custom validation message as soon as the email is valid</li>
<li>Add custom validation logic to the State field without using an attribute</li>
<li>Apply custom styling to the validation error messages</li>
<li>Prevent form submission if there are validation errors.</li>
</ul>
<p>To achieve these goals you will:</p>
<ol>
<li>Add a keyup event listener to the email field to present a custom message</li>
<li>Add <code>validateForm</code> function to handle validation logic</li>
<li>Modify the form submit event listener to validate the form</li>
<li>Loop through the form elements and check their validity</li>
<li>Set or clear the validation error messages</li>
<li>Add custom validation logic to the state field</li>
</ol>
<h2 id="validate-email-field">Validate email field</h2>
<p>First let's add a <code>keyup</code> listener to check the validity of the email field as the user types. In order to do this we will need a reference to the email field.</p>
<pre><code class="js">var email = document.querySelector('[name=&quot;email&quot;]')
</code></pre>

<p>Inside of our <code>keyup</code> listener method, we will want to check the validity of the email. We can do this by getting a reference to the <code>currentTarget</code> on the passed in <code>event</code> object. This is going to be our <code>email</code> input.</p>
<pre><code class="js">var email = document.querySelector('[name=&quot;email&quot;]')

var emailListener = function(evt) {
  var input = evt.currentTarget
}
email.addEventListener('keyup', emailListener)
</code></pre>

<p>We can then check the input's <code>validity.typeMismatch</code> property in order to determine if the email the user has typed is valid or not.</p>
<p>If there is a problem with the email validity, <code>typeMatch</code> will be <code>true</code>. This is our opportunity to set a custom error message using the <code>setCustomValidity</code> function.</p>
<p>If we pass <code>''</code> to <code>setCustomValidity</code> the field will be considered valid. There are different types of <a href="https://developer.mozilla.org/en-US/docs/Web/API/ValidityState">validityStates</a>.</p>
<pre><code class="js">var email = document.querySelector('[name=&quot;email&quot;]')

var emailListener = function(evt) {
  var input = evt.currentTarget
  if (input.validity.typeMismatch) {
    input.setCustomValidity('Oops, try a real email address.')
  } else {
    input.setCustomValidity('')
  }
}
email.addEventListener('keyup', emailListener)
</code></pre>

<p>Let's try out the new logic. When we visit our form, add our name, type in an invalid email address, and hit submit, we now are able to see our custom error message.</p>
<h2 id="validate-form">Validate form</h2>
<p>We can use the technique above to handle each validated field, but we are still stuck with the standard formatting for the messages. To get more control, we will need to turn off the automatic validation and handle the submission event ourselves.</p>
<p>In order to do this, we need to disable the automatica validation behavior on our form.</p>
<pre><code class="js">form.noValidate = true
</code></pre>

<p>ProTip™: The same thing can be achieved byadding a <code>novalidate</code> attribute to the form element.</p>
<p>We can confirm that validation is off now by entering garbage data in the form and submitting.</p>
<p>With the automatic validation turned off, we now have more control over when the validation check is done.</p>
<p>Let's create a new function, <code>validateForm</code>, to handle the validation check. This function, after we implement it fully, will determine any field errors and allow the form to determine if it valid.</p>
<pre><code class="js">var validateForm = function(form) { }
</code></pre>

<h3 id="update-submit-handler">Update submit handler</h3>
<p>Back in the "Add submit event" section we added a <code>submit</code> event handler. We need to modify that to call the <code>validateForm</code> method.</p>
<pre><code class="js">var submitHandler = function(evt) {
  evt.preventDefault()

  var form = evt.target
  validateForm(form)

  // ...
}
</code></pre>

<p>Now we need to have the form check if it is valid before submitting data to the server. The <code>form</code> element has a convenient <code>checkValidity</code> function to do just that.</p>
<pre><code class="js">
var submitHandler = function(evt) {
  evt.preventDefault()

  var form = evt.target
  validateForm(form)

  // if no error, go ahead and submit
  if (form.checkValidity()) {
    // ...
  }
}
</code></pre>

<h3 id="loop-through-the-fields">Loop through the fields</h3>
<p>Every form has an elements array and we can use this to loop through the fields.</p>
<pre><code class="js">var validateForm = function(form) {
  for (var f = 0; f &lt; form.elements.length; f++) {

  }
}
</code></pre>

<p>Within the loop, get a reference to the current field.</p>
<pre><code class="js">var validateForm = function(form) {
  for (var f = 0; f &lt; form.elements.length; f++) {
    var field = form.elements[f]
  }
}
</code></pre>

<p>The behavior of the form hasn't changed so charge on to the next section.</p>
<h2 id="check-the-field-validity">Check the field validity</h2>
<p>We are going to start off using the native validation check for a field for our validations, first.</p>
<p>Let's create a new function called <code>isValid</code> that recieves a field as a parameter.</p>
<p>Like the form, fields have a <code>checkValidity</code> method. Use this method to determine the return value for the function.</p>
<pre><code class="js">var isValid = function(field) {
  return field.checkValidity()
}
</code></pre>

<p>Now we can call this method for each of the fields we pass over in our loop.</p>
<pre><code class="js">var validateForm = function(form) {
  for (var f = 0; f &lt; form.elements.length; f++) {
    var field = form.elements[f]
    if(isValid(field)) {
      // remove error styles and messages
    } else {
      // style field, show error, etc.
    }
  }
}
</code></pre>

<h3 id="set-and-clear-error-messages">Set and clear error messages</h3>
<p>Under each of the the input's in the <code>app/index.html</code> we are going to want to add a <code>&lt;span&gt;&lt;/span&gt;</code> element so that we have somewhere to output an error message. Let's give it a custom class of <code>error-message</code> so that we cans style it later.</p>
<pre><code class="html">&lt;span class='error-message'&gt;&lt;/span&gt;
</code></pre>

<p>Let's make a function that sets the error message for a given field.</p>
<pre><code class="js">var setError = function(field) { }
</code></pre>

<p>In order to get a reference to the <code>span</code> immediately after the field we want to display the error for, we will use the <code>nextElementSibling</code> method.</p>
<p>Once we have our <code>span</code> reference, all we need to do is set the <code>innerHTML</code> to be the field's <code>validationMessage</code>. The <code>validationMessage</code> is either the default message from the browser or a custom message that we set.</p>
<pre><code class="js">var setError = function(field) {
  var error = field.nextElementSibling
  if (error) {
    error.innerHTML = field.validationMessage
  }
}
</code></pre>

<p>Let's also setup a similar function to clear our error message when the field becomes valid again.</p>
<pre><code class="js">var clearError = function(field) {
  var error = field.nextElementSibling
  if (error) {
    error.innerHTML = ''
  }
}
</code></pre>

<p>ProTip™: This is just one way of handling error messages. For example, you could use CSS to show and hide error messages or put all validation errors in a central location on the page.</p>
<p>Now that we have created our <code>setError</code> and <code>clearError</code> methods, we can call them from our <code>validateForm</code> method.</p>
<pre><code class="js">var validateForm = function(form) {
  for (var f = 0; f &lt; form.elements.length; f++) {
    var field = form.elements[f]
    if(isValid(field)) {
      clearError(field)
    } else {
      setError(field)
    }
  }
}
</code></pre>

<p>When we go to the browser and try it out, we will now see our custom error message from the email input. But as we type in the email field and put in a valid email, the message does not disappear.</p>
<p>Let's add the <code>clearError</code> to our email keyup handler.</p>
<pre><code class="js">var email = document.querySelector('[name=&quot;email&quot;]')

var emailListener = function(evt) {
  var input = evt.currentTarget
  if (input.validity.typeMismatch) {
    input.setCustomValidity('Oops, try a real email address.')
  } else {
    input.setCustomValidity('')
    clearError(input)
  }
}
email.addEventListener('keyup', emailListener)
</code></pre>

<h3 id="custom-validation-logic">Custom validation logic</h3>
<p>Time for the bonus round! Custom validation logic could involve evaluating multiple fields on the form, making a call to the server, or performing some calculation in a worker thread. While those are beyond the time you have for this workshop, this section will walk you through creating some custom logic.</p>
<p>As an example, let's add a custom 'State' validation check. We will add this logic to the top of the <code>isValid</code> function from earlier.</p>
<p>First, we wnat to check if the field tha is passed in is in fact the <code>state</code> field, so verify the <code>name</code> matches <code>state</code>.</p>
<p>For this example, let's say that only "CA", "TX", and "NY" are valid states.</p>
<pre><code class="js"> var sValid = function(field) {
  if (field.name === 'state') {
    var validStates = ['CA', 'TX', 'NY']
    if (validStates.indexOf(field.value) === -1) {
      // invalid state
    } else {
      // valid state
    }
  }
  return field.checkValidity()
}
</code></pre>

<p>When the state is invalid we want to set a custom validity message. When it is valid, we can set an empty string like before.</p>
<pre><code class="js">var sValid = function(field) {
  if (validStates.indexOf(field.value) === -1) {
    field.setCustomValidity('Please provide a valid state (CA, TX, or NY)')
  } else {
    field.setCustomValidity('')
  }
  return field.checkValidity()
}
</code></pre>

<p>Now when we try to submit without a state or with an invalid state we should see our custom error message like before.</p>
<h1 id="welcome-text-with-cookies">Welcome text with cookies</h1>
<p>Cookies are a classic way to provide a unique visitor experience based on previous visits.  In our case we would like to show a generic welcome message the first time a user visits our site, but show an alternative, and more personalized message when a user returns for any additional visits from the same device.  Note that cookies are stored on the user’s device, so if they return from a new device or clear their cookies, we won’t have a cookie and will not know they are a returning visitor.  Cookies are often associated with tracking of user visits, be sure to read up on that before implementing on your own.</p>
<p>Here are the basics.   Cookies are stored as key value pairs as a strings.  The DOM API allows you to set cookies by assigning a value to document.cookie.  It must have a name, should have a value, and may have an expiration date for example:</p>
<pre><code class="js">document.cookie = 'returning=true; expires=Mon, 1 Feb 2016 12:00:UTC;'
</code></pre>

<p>This would set a cookie with the key = 'returning' and value = 'true', as well as an expiration date.  This is when the cookie will go bye bye.</p>
<p>Getting a cookie involves more work because you have to parse the value of document.cookie (which remember is just a plain text string with ; separators).  It could include quite a few key value pairs, so most users will roll their own GET and SET methods to deal with parsing cookies.</p>
<p>Let’s add cookie set and get methods to help us handle our visitor’s session.</p>
<pre><code class="js">function setCookie(cookieName, cookieValue, cookieDays) {
  var expireTime = new Date()
  expireTime.setTime(expireTime.getTime() + cookieDays * 24 * 60 * 60)
  var expires = &quot;expires=&quot; + expireTime.toUTCString()
  document.cookie = cookieName + &quot;=&quot; + cookieValue + &quot;; &quot; + expires
}

function getCookie(cookieName) {
  var name = cookieName + &quot;=&quot;
  var cookieArray = document.cookie.split(';')
  for(var i=0; i &lt; cookieArray.length; i++) {
    var cookieStr = cookieArray[i]
    while (cookieStr.charAt(0)==' ') {
      cookieStr = cookieStr.substring(1)
    }
    if (cookieStr.indexOf(name) == 0) {
      return cookieStr.substring(name.length,cookieStr.length)
    }
  }
  return &quot;&quot;;
}
</code></pre>

<p>Then we will add a conditional block of code that will update the welcome message when a user returns, or set a cookie if its the first visit (or if the cookies have been cleared or expired).</p>
<pre><code class="js">if(getCookie('returning') === 'yes') {
  document.querySelector('.greeting').innerHTML = &quot;Welcome back to the program.&quot;
} else {
  setCookie('returning', 'yes', 2)
}
</code></pre>

<p>Then try refreshing the page and watch it add a custom greeting.  You can clear out your cookies using the Chrome Dev tools &gt; Resources &gt; Cookies</p>
<p>As a bonus try refactoring this code to cookie and display the users name in the greeting message when they return.</p>
<p>A couple of other fun facts about cookies: You can store objects in cookies, but you will need to be sure to serialize them and they must be strings when assigned to document.cookie.  Cookie security is handled for you:  Cookies are stored with a security feature tied to the domain that was used to store the cookie.  That means that your code running in the browser can only read the cookies that were set on the same domain.  Also note, cookies are stored as strings in plain text, so any savvy user can look at the cookies on their machine (delete, or modify them) as they see fit.</p>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../bonus/" class="btn btn-neutral float-right" title="Bonus">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../ajax/" class="btn btn-neutral" title="AJAX Form Submission"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
	  
        </div>
      </div>

    </section>

  </div>

<div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href="../ajax/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../bonus/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>

</body>
</html>
